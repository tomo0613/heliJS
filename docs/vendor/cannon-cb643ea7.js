import{M as De,S as Wt,B as jt,P as Ht,a as nt,C as Xe,b as Mt,F as At}from"./three-1570321e.js";class Z{constructor(t=[0,0,0,0,0,0,0,0,0]){this.elements=void 0,this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t=new c){const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e=new c){const s=this.elements,i=t.x,n=t.y,o=t.z;return e.x=s[0]*i+s[1]*n+s[2]*o,e.y=s[3]*i+s[4]*n+s[5]*o,e.z=s[6]*i+s[7]*n+s[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e=new Z){const s=this.elements,i=t.elements,n=e.elements,o=s[0],r=s[1],a=s[2],l=s[3],h=s[4],u=s[5],d=s[6],f=s[7],p=s[8],y=i[0],m=i[1],g=i[2],v=i[3],b=i[4],E=i[5],N=i[6],M=i[7],T=i[8];return n[0]=o*y+r*v+a*N,n[1]=o*m+r*b+a*M,n[2]=o*g+r*E+a*T,n[3]=l*y+h*v+u*N,n[4]=l*m+h*b+u*M,n[5]=l*g+h*E+u*T,n[6]=d*y+f*v+p*N,n[7]=d*m+f*b+p*M,n[8]=d*g+f*E+p*T,e}scale(t,e=new Z){const s=this.elements,i=e.elements;for(let n=0;n!==3;n++)i[3*n+0]=t.x*s[3*n+0],i[3*n+1]=t.y*s[3*n+1],i[3*n+2]=t.z*s[3*n+2];return e}solve(t,e=new c){const s=3,i=4,n=[];let o,r;for(o=0;o<s*i;o++)n.push(0);for(o=0;o<3;o++)for(r=0;r<3;r++)n[o+i*r]=this.elements[o+3*r];n[3+4*0]=t.x,n[3+4*1]=t.y,n[3+4*2]=t.z;let a=3;const l=a;let h;const u=4;let d;do{if(o=l-a,n[o+i*o]===0){for(r=o+1;r<l;r++)if(n[o+i*r]!==0){h=u;do d=u-h,n[d+i*o]+=n[d+i*r];while(--h);break}}if(n[o+i*o]!==0)for(r=o+1;r<l;r++){const f=n[o+i*r]/n[o+i*o];h=u;do d=u-h,n[d+i*r]=d<=o?0:n[d+i*r]-n[d+i*o]*f;while(--h)}}while(--a);if(e.z=n[2*i+3]/n[2*i+2],e.y=(n[1*i+3]-n[1*i+2]*e.z)/n[1*i+1],e.x=(n[0*i+3]-n[0*i+2]*e.z-n[0*i+1]*e.y)/n[0*i+0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw"Could not solve equation! Got x=["+e.toString()+"], b=["+t.toString()+"], A=["+this.toString()+"]";return e}e(t,e,s){if(s===void 0)return this.elements[e+3*t];this.elements[e+3*t]=s}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";const e=",";for(let s=0;s<9;s++)t+=this.elements[s]+e;return t}reverse(t=new Z){const e=3,s=6,i=Ue;let n,o;for(n=0;n<3;n++)for(o=0;o<3;o++)i[n+s*o]=this.elements[n+3*o];i[3+6*0]=1,i[3+6*1]=0,i[3+6*2]=0,i[4+6*0]=0,i[4+6*1]=1,i[4+6*2]=0,i[5+6*0]=0,i[5+6*1]=0,i[5+6*2]=1;let r=3;const a=r;let l;const h=s;let u;do{if(n=a-r,i[n+s*n]===0){for(o=n+1;o<a;o++)if(i[n+s*o]!==0){l=h;do u=h-l,i[u+s*n]+=i[u+s*o];while(--l);break}}if(i[n+s*n]!==0)for(o=n+1;o<a;o++){const d=i[n+s*o]/i[n+s*n];l=h;do u=h-l,i[u+s*o]=u<=n?0:i[u+s*o]-i[u+s*n]*d;while(--l)}}while(--r);n=2;do{o=n-1;do{const d=i[n+s*o]/i[n+s*n];l=s;do u=s-l,i[u+s*o]=i[u+s*o]-i[u+s*n]*d;while(--l)}while(o--)}while(--n);n=2;do{const d=1/i[n+s*n];l=s;do u=s-l,i[u+s*n]=i[u+s*n]*d;while(--l)}while(n--);n=2;do{o=2;do{if(u=i[e+o+s*n],isNaN(u)||u===1/0)throw"Could not reverse! A=["+this.toString()+"]";t.e(n,o,u)}while(o--)}while(n--);return t}setRotationFromQuaternion(t){const e=t.x,s=t.y,i=t.z,n=t.w,o=e+e,r=s+s,a=i+i,l=e*o,h=e*r,u=e*a,d=s*r,f=s*a,p=i*a,y=n*o,m=n*r,g=n*a,v=this.elements;return v[3*0+0]=1-(d+p),v[3*0+1]=h-g,v[3*0+2]=u+m,v[3*1+0]=h+g,v[3*1+1]=1-(l+p),v[3*1+2]=f-y,v[3*2+0]=u-m,v[3*2+1]=f+y,v[3*2+2]=1-(l+d),this}transpose(t=new Z){const e=this.elements,s=t.elements;let i;return s[0]=e[0],s[4]=e[4],s[8]=e[8],i=e[1],s[1]=e[3],s[3]=i,i=e[2],s[2]=e[6],s[6]=i,i=e[5],s[5]=e[7],s[7]=i,t}}const Ue=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class c{constructor(t=0,e=0,s=0){this.x=void 0,this.y=void 0,this.z=void 0,this.x=t,this.y=e,this.z=s}cross(t,e=new c){const s=t.x,i=t.y,n=t.z,o=this.x,r=this.y,a=this.z;return e.x=r*n-a*i,e.y=a*s-o*n,e.z=o*i-r*s,e}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(e)e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z;else return new c(this.x+t.x,this.y+t.y,this.z+t.z)}vsub(t,e){if(e)e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z;else return new c(this.x-t.x,this.y-t.y,this.z-t.z)}crossmat(){return new Z([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,s=this.z,i=Math.sqrt(t*t+e*e+s*s);if(i>0){const n=1/i;this.x*=n,this.y*=n,this.z*=n}else this.x=0,this.y=0,this.z=0;return i}unit(t=new c){const e=this.x,s=this.y,i=this.z;let n=Math.sqrt(e*e+s*s+i*i);return n>0?(n=1/n,t.x=e*n,t.y=s*n,t.z=i*n):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,s=this.z;return Math.sqrt(t*t+e*e+s*s)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,s=this.y,i=this.z,n=t.x,o=t.y,r=t.z;return Math.sqrt((n-e)*(n-e)+(o-s)*(o-s)+(r-i)*(r-i))}distanceSquared(t){const e=this.x,s=this.y,i=this.z,n=t.x,o=t.y,r=t.z;return(n-e)*(n-e)+(o-s)*(o-s)+(r-i)*(r-i)}scale(t,e=new c){const s=this.x,i=this.y,n=this.z;return e.x=t*s,e.y=t*i,e.z=t*n,e}vmul(t,e=new c){return e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,s=new c){return s.x=this.x+t*e.x,s.y=this.y+t*e.y,s.z=this.z+t*e.z,s}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(t=new c){return t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const s=this.length();if(s>0){const i=$e,n=1/s;i.set(this.x*n,this.y*n,this.z*n);const o=Ze;Math.abs(i.x)<.9?(o.set(1,0,0),i.cross(o,t)):(o.set(0,1,0),i.cross(o,t)),i.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return this.x+","+this.y+","+this.z}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,s){const i=this.x,n=this.y,o=this.z;s.x=i+(t.x-i)*e,s.y=n+(t.y-n)*e,s.z=o+(t.z-o)*e}almostEquals(t,e=1e-6){return!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t=1e-6){return!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(Yt),Yt.almostEquals(t,e)}clone(){return new c(this.x,this.y,this.z)}}c.ZERO=void 0;c.UNIT_X=void 0;c.UNIT_Y=void 0;c.UNIT_Z=void 0;c.ZERO=new c(0,0,0);c.UNIT_X=new c(1,0,0);c.UNIT_Y=new c(0,1,0);c.UNIT_Z=new c(0,0,1);const $e=new c,Ze=new c,Yt=new c;class U{constructor(t={}){this.lowerBound=void 0,this.upperBound=void 0,this.lowerBound=new c,this.upperBound=new c,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,s,i){const n=this.lowerBound,o=this.upperBound,r=s;n.copy(t[0]),r&&r.vmult(n,n),o.copy(n);for(let a=1;a<t.length;a++){let l=t[a];r&&(r.vmult(l,Gt),l=Gt),l.x>o.x&&(o.x=l.x),l.x<n.x&&(n.x=l.x),l.y>o.y&&(o.y=l.y),l.y<n.y&&(n.y=l.y),l.z>o.z&&(o.z=l.z),l.z<n.z&&(n.z=l.z)}return e&&(e.vadd(n,n),e.vadd(o,o)),i&&(n.x-=i,n.y-=i,n.z-=i,o.x+=i,o.y+=i,o.z+=i),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new U().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,s=this.upperBound,i=t.lowerBound,n=t.upperBound,o=i.x<=s.x&&s.x<=n.x||e.x<=n.x&&n.x<=s.x,r=i.y<=s.y&&s.y<=n.y||e.y<=n.y&&n.y<=s.y,a=i.z<=s.z&&s.z<=n.z||e.z<=n.z&&n.z<=s.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,s=this.upperBound,i=t.lowerBound,n=t.upperBound;return e.x<=i.x&&s.x>=n.x&&e.y<=i.y&&s.y>=n.y&&e.z<=i.z&&s.z>=n.z}getCorners(t,e,s,i,n,o,r,a){const l=this.lowerBound,h=this.upperBound;t.copy(l),e.set(h.x,l.y,l.z),s.set(h.x,h.y,l.z),i.set(l.x,h.y,h.z),n.set(h.x,l.y,h.z),o.set(l.x,h.y,l.z),r.set(l.x,l.y,h.z),a.copy(h)}toLocalFrame(t,e){const s=Dt,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],l=s[5],h=s[6],u=s[7];this.getCorners(i,n,o,r,a,l,h,u);for(let d=0;d!==8;d++){const f=s[d];t.pointToLocal(f,f)}return e.setFromPoints(s)}toWorldFrame(t,e){const s=Dt,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],l=s[5],h=s[6],u=s[7];this.getCorners(i,n,o,r,a,l,h,u);for(let d=0;d!==8;d++){const f=s[d];t.pointToWorld(f,f)}return e.setFromPoints(s)}overlapsRay(t){const{direction:e,from:s}=t,i=1/e.x,n=1/e.y,o=1/e.z,r=(this.lowerBound.x-s.x)*i,a=(this.upperBound.x-s.x)*i,l=(this.lowerBound.y-s.y)*n,h=(this.upperBound.y-s.y)*n,u=(this.lowerBound.z-s.z)*o,d=(this.upperBound.z-s.z)*o,f=Math.max(Math.max(Math.min(r,a),Math.min(l,h)),Math.min(u,d)),p=Math.min(Math.min(Math.max(r,a),Math.max(l,h)),Math.max(u,d));return!(p<0||f>p)}}const Gt=new c,Dt=[new c,new c,new c,new c,new c,new c,new c,new c];class Xt{constructor(){this.matrix=void 0,this.matrix=[]}get(t,e){let{index:s}=t,{index:i}=e;if(i>s){const n=i;i=s,s=n}return this.matrix[(s*(s+1)>>1)+i-1]}set(t,e,s){let{index:i}=t,{index:n}=e;if(n>i){const o=n;n=i,i=o}this.matrix[(i*(i+1)>>1)+n-1]=s?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class Ut{constructor(){this._listeners=void 0}addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;return s[t]===void 0&&(s[t]=[]),s[t].includes(e)||s[t].push(e),this}hasEventListener(t,e){if(this._listeners===void 0)return!1;const s=this._listeners;return!!(s[t]!==void 0&&s[t].includes(e))}hasAnyEventListener(t){return this._listeners===void 0?!1:this._listeners[t]!==void 0}removeEventListener(t,e){if(this._listeners===void 0)return this;const s=this._listeners;if(s[t]===void 0)return this;const i=s[t].indexOf(e);return i!==-1&&s[t].splice(i,1),this}dispatchEvent(t){if(this._listeners===void 0)return this;const s=this._listeners[t.type];if(s!==void 0){t.target=this;for(let i=0,n=s.length;i<n;i++)s[i].call(this,t)}return this}}class j{constructor(t=0,e=0,s=0,i=1){this.x=void 0,this.y=void 0,this.z=void 0,this.w=void 0,this.x=t,this.y=e,this.z=s,this.w=i}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}toString(){return this.x+","+this.y+","+this.z+","+this.w}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const s=Math.sin(e*.5);return this.x=t.x*s,this.y=t.y*s,this.z=t.z*s,this.w=Math.cos(e*.5),this}toAxisAngle(t=new c){this.normalize();const e=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/s,t.y=this.y/s,t.z=this.z/s),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const s=Ke,i=Qe;t.tangents(s,i),this.setFromAxisAngle(s,Math.PI)}else{const s=t.cross(e);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e=new j){const s=this.x,i=this.y,n=this.z,o=this.w,r=t.x,a=t.y,l=t.z,h=t.w;return e.x=s*h+o*r+i*l-n*a,e.y=i*h+o*a+n*r-s*l,e.z=n*h+o*l+s*a-i*r,e.w=o*h-s*r-i*a-n*l,e}inverse(t=new j){const e=this.x,s=this.y,i=this.z,n=this.w;this.conjugate(t);const o=1/(e*e+s*s+i*i+n*n);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t=new j){return t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return t===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e=new c){const s=t.x,i=t.y,n=t.z,o=this.x,r=this.y,a=this.z,l=this.w,h=l*s+r*n-a*i,u=l*i+a*s-o*n,d=l*n+o*i-r*s,f=-o*s-r*i-a*n;return e.x=h*l+f*-o+u*-a-d*-r,e.y=u*l+f*-r+d*-o-h*-a,e.z=d*l+f*-a+h*-r-u*-o,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e="YZX"){let s,i,n;const o=this.x,r=this.y,a=this.z,l=this.w;switch(e){case"YZX":const h=o*r+a*l;if(h>.499&&(s=2*Math.atan2(o,l),i=Math.PI/2,n=0),h<-.499&&(s=-2*Math.atan2(o,l),i=-Math.PI/2,n=0),s===void 0){const u=o*o,d=r*r,f=a*a;s=Math.atan2(2*r*l-2*o*a,1-2*d-2*f),i=Math.asin(2*h),n=Math.atan2(2*o*l-2*r*a,1-2*u-2*f)}break;default:throw new Error("Euler order "+e+" not supported yet.")}t.y=s,t.z=i,t.x=n}setFromEuler(t,e,s,i="XYZ"){const n=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(s/2),a=Math.sin(t/2),l=Math.sin(e/2),h=Math.sin(s/2);return i==="XYZ"?(this.x=a*o*r+n*l*h,this.y=n*l*r-a*o*h,this.z=n*o*h+a*l*r,this.w=n*o*r-a*l*h):i==="YXZ"?(this.x=a*o*r+n*l*h,this.y=n*l*r-a*o*h,this.z=n*o*h-a*l*r,this.w=n*o*r+a*l*h):i==="ZXY"?(this.x=a*o*r-n*l*h,this.y=n*l*r+a*o*h,this.z=n*o*h+a*l*r,this.w=n*o*r-a*l*h):i==="ZYX"?(this.x=a*o*r-n*l*h,this.y=n*l*r+a*o*h,this.z=n*o*h-a*l*r,this.w=n*o*r+a*l*h):i==="YZX"?(this.x=a*o*r+n*l*h,this.y=n*l*r+a*o*h,this.z=n*o*h-a*l*r,this.w=n*o*r-a*l*h):i==="XZY"&&(this.x=a*o*r-n*l*h,this.y=n*l*r-a*o*h,this.z=n*o*h+a*l*r,this.w=n*o*r+a*l*h),this}clone(){return new j(this.x,this.y,this.z,this.w)}slerp(t,e,s=new j){const i=this.x,n=this.y,o=this.z,r=this.w;let a=t.x,l=t.y,h=t.z,u=t.w,d,f,p,y,m;return f=i*a+n*l+o*h+r*u,f<0&&(f=-f,a=-a,l=-l,h=-h,u=-u),1-f>1e-6?(d=Math.acos(f),p=Math.sin(d),y=Math.sin((1-e)*d)/p,m=Math.sin(e*d)/p):(y=1-e,m=e),s.x=y*i+m*a,s.y=y*n+m*l,s.z=y*o+m*h,s.w=y*r+m*u,s}integrate(t,e,s,i=new j){const n=t.x*s.x,o=t.y*s.y,r=t.z*s.z,a=this.x,l=this.y,h=this.z,u=this.w,d=e*.5;return i.x+=d*(n*u+o*h-r*l),i.y+=d*(o*u+r*a-n*h),i.z+=d*(r*u+n*l-o*a),i.w+=d*(-n*a-o*l-r*h),i}}const Ke=new c,Qe=new c,Je={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class P{constructor(t={}){this.id=void 0,this.type=void 0,this.boundingSphereRadius=void 0,this.collisionResponse=void 0,this.collisionFilterGroup=void 0,this.collisionFilterMask=void 0,this.material=void 0,this.body=void 0,this.id=P.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=t.collisionResponse?t.collisionResponse:!0,this.collisionFilterGroup=t.collisionFilterGroup!==void 0?t.collisionFilterGroup:1,this.collisionFilterMask=t.collisionFilterMask!==void 0?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw"computeBoundingSphereRadius() not implemented for shape type "+this.type}volume(){throw"volume() not implemented for shape type "+this.type}calculateLocalInertia(t,e){throw"calculateLocalInertia() not implemented for shape type "+this.type}calculateWorldAABB(t,e,s,i){throw"calculateWorldAABB() not implemented for shape type "+this.type}}P.idCounter=0;P.types=Je;class k{constructor(t={}){this.position=void 0,this.quaternion=void 0,this.position=new c,this.quaternion=new j,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return k.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return k.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e=new c){return this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,s,i=new c){return s.vsub(t,i),e.conjugate($t),$t.vmult(i,i),i}static pointToWorldFrame(t,e,s,i=new c){return e.vmult(s,i),i.vadd(t,i),i}static vectorToWorldFrame(t,e,s=new c){return t.vmult(e,s),s}static vectorToLocalFrame(t,e,s,i=new c){return e.w*=-1,e.vmult(s,i),e.w*=-1,i}}const $t=new j;class ot extends P{constructor(t={}){const{vertices:e=[],faces:s=[],normals:i=[],axes:n,boundingSphereRadius:o}=t;super({type:P.types.CONVEXPOLYHEDRON});this.vertices=void 0,this.faces=void 0,this.faceNormals=void 0,this.worldVertices=void 0,this.worldVerticesNeedsUpdate=void 0,this.worldFaceNormals=void 0,this.worldFaceNormalsNeedsUpdate=void 0,this.uniqueAxes=void 0,this.uniqueEdges=void 0,this.vertices=e,this.faces=s,this.faceNormals=i,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,s=this.uniqueEdges;s.length=0;const i=new c;for(let n=0;n!==t.length;n++){const o=t[n],r=o.length;for(let a=0;a!==r;a++){const l=(a+1)%r;e[o[a]].vsub(e[o[l]],i),i.normalize();let h=!1;for(let u=0;u!==s.length;u++)if(s[u].almostEquals(i)||s[u].almostEquals(i)){h=!0;break}h||s.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let i=0;i<this.faces[t].length;i++)if(!this.vertices[this.faces[t][i]])throw new Error("Vertex "+this.faces[t][i]+" not found!");const e=this.faceNormals[t]||new c;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const s=this.vertices[this.faces[t][0]];if(e.dot(s)<0){console.error(".faceNormals["+t+"] = Vec3("+e.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");for(let i=0;i<this.faces[t].length;i++)console.warn(".vertices["+this.faces[t][i]+"] = Vec3("+this.vertices[this.faces[t][i]].toString()+")")}}}getFaceNormal(t,e){const s=this.faces[t],i=this.vertices[s[0]],n=this.vertices[s[1]],o=this.vertices[s[2]];ot.computeNormal(i,n,o,e)}static computeNormal(t,e,s,i){const n=new c,o=new c;e.vsub(t,o),s.vsub(e,n),n.cross(o,i),i.isZero()||i.normalize()}clipAgainstHull(t,e,s,i,n,o,r,a,l){const h=new c;let u=-1,d=-Number.MAX_VALUE;for(let p=0;p<s.faces.length;p++){h.copy(s.faceNormals[p]),n.vmult(h,h);const y=h.dot(o);y>d&&(d=y,u=p)}const f=[];for(let p=0;p<s.faces[u].length;p++){const y=s.vertices[s.faces[u][p]],m=new c;m.copy(y),n.vmult(m,m),i.vadd(m,m),f.push(m)}u>=0&&this.clipFaceAgainstHull(o,t,e,f,r,a,l)}findSeparatingAxis(t,e,s,i,n,o,r,a){const l=new c,h=new c,u=new c,d=new c,f=new c,p=new c;let y=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let g=0;g!==m.uniqueAxes.length;g++){s.vmult(m.uniqueAxes[g],l);const v=m.testSepAxis(l,t,e,s,i,n);if(v===!1)return!1;v<y&&(y=v,o.copy(l))}else{const g=r?r.length:m.faces.length;for(let v=0;v<g;v++){const b=r?r[v]:v;l.copy(m.faceNormals[b]),s.vmult(l,l);const E=m.testSepAxis(l,t,e,s,i,n);if(E===!1)return!1;E<y&&(y=E,o.copy(l))}}if(t.uniqueAxes)for(let g=0;g!==t.uniqueAxes.length;g++){n.vmult(t.uniqueAxes[g],h);const v=m.testSepAxis(h,t,e,s,i,n);if(v===!1)return!1;v<y&&(y=v,o.copy(h))}else{const g=a?a.length:t.faces.length;for(let v=0;v<g;v++){const b=a?a[v]:v;h.copy(t.faceNormals[b]),n.vmult(h,h);const E=m.testSepAxis(h,t,e,s,i,n);if(E===!1)return!1;E<y&&(y=E,o.copy(h))}}for(let g=0;g!==m.uniqueEdges.length;g++){s.vmult(m.uniqueEdges[g],d);for(let v=0;v!==t.uniqueEdges.length;v++)if(n.vmult(t.uniqueEdges[v],f),d.cross(f,p),!p.almostZero()){p.normalize();const b=m.testSepAxis(p,t,e,s,i,n);if(b===!1)return!1;b<y&&(y=b,o.copy(p))}}return i.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,s,i,n,o){const r=this;ot.project(r,t,s,i,Pt),ot.project(e,t,n,o,_t);const a=Pt[0],l=Pt[1],h=_t[0],u=_t[1];if(a<u||h<l)return!1;const d=a-u,f=h-l;return d<f?d:f}calculateLocalInertia(t,e){const s=new c,i=new c;this.computeLocalAABB(i,s);const n=s.x-i.x,o=s.y-i.y,r=s.z-i.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*n*2*n+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*n*2*n)}getPlaneConstantOfFace(t){const e=this.faces[t],s=this.faceNormals[t],i=this.vertices[e[0]];return-s.dot(i)}clipFaceAgainstHull(t,e,s,i,n,o,r){const a=new c,l=new c,h=new c,u=new c,d=new c,f=new c,p=new c,y=new c,m=this,g=[],v=i,b=g;let E=-1,N=Number.MAX_VALUE;for(let A=0;A<m.faces.length;A++){a.copy(m.faceNormals[A]),s.vmult(a,a);const B=a.dot(t);B<N&&(N=B,E=A)}if(E<0)return;const M=m.faces[E];M.connectedFaces=[];for(let A=0;A<m.faces.length;A++)for(let B=0;B<m.faces[A].length;B++)M.indexOf(m.faces[A][B])!==-1&&A!==E&&M.connectedFaces.indexOf(A)===-1&&M.connectedFaces.push(A);const T=M.length;for(let A=0;A<T;A++){const B=m.vertices[M[A]],_=m.vertices[M[(A+1)%T]];B.vsub(_,l),h.copy(l),s.vmult(h,h),e.vadd(h,h),u.copy(this.faceNormals[E]),s.vmult(u,u),e.vadd(u,u),h.cross(u,d),d.negate(d),f.copy(B),s.vmult(f,f),e.vadd(f,f);const w=M.connectedFaces[A];p.copy(this.faceNormals[w]);const z=this.getPlaneConstantOfFace(w);y.copy(p),s.vmult(y,y);const I=z-y.dot(e);for(this.clipFaceAgainstPlane(v,b,y,I);v.length;)v.shift();for(;b.length;)v.push(b.shift())}p.copy(this.faceNormals[E]);const C=this.getPlaneConstantOfFace(E);y.copy(p),s.vmult(y,y);const S=C-y.dot(e);for(let A=0;A<v.length;A++){let B=y.dot(v[A])+S;if(B<=n&&(console.log("clamped: depth="+B+" to minDist="+n),B=n),B<=o){const _=v[A];if(B<=1e-6){const w={point:_,normal:y,depth:B};r.push(w)}}}}clipFaceAgainstPlane(t,e,s,i){let n,o;const r=t.length;if(r<2)return e;let a=t[t.length-1],l=t[0];n=s.dot(a)+i;for(let h=0;h<r;h++){if(l=t[h],o=s.dot(l)+i,n<0)if(o<0){const u=new c;u.copy(l),e.push(u)}else{const u=new c;a.lerp(l,n/(n-o),u),e.push(u)}else if(o<0){const u=new c;a.lerp(l,n/(n-o),u),e.push(u),e.push(l)}a=l,n=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new c);const s=this.vertices,i=this.worldVertices;for(let n=0;n!==this.vertices.length;n++)e.vmult(s[n],i[n]),t.vadd(i[n],i[n]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const s=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const n=s[i];n.x<t.x?t.x=n.x:n.x>e.x&&(e.x=n.x),n.y<t.y?t.y=n.y:n.y>e.y&&(e.y=n.y),n.z<t.z?t.z=n.z:n.z>e.z&&(e.z=n.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new c);const s=this.faceNormals,i=this.worldFaceNormals;for(let n=0;n!==e;n++)t.vmult(s[n],i[n]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let s=0;s!==e.length;s++){const i=e[s].lengthSquared();i>t&&(t=i)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,s,i){const n=this.vertices;let o,r,a,l,h,u,d=new c;for(let f=0;f<n.length;f++){d.copy(n[f]),e.vmult(d,d),t.vadd(d,d);const p=d;(o===void 0||p.x<o)&&(o=p.x),(l===void 0||p.x>l)&&(l=p.x),(r===void 0||p.y<r)&&(r=p.y),(h===void 0||p.y>h)&&(h=p.y),(a===void 0||p.z<a)&&(a=p.z),(u===void 0||p.z>u)&&(u=p.z)}s.set(o,r,a),i.set(l,h,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t=new c){const e=this.vertices;for(let s=0;s<e.length;s++)t.vadd(e[s],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const s=this.vertices.length,i=this.vertices;if(e){for(let n=0;n<s;n++){const o=i[n];e.vmult(o,o)}for(let n=0;n<this.faceNormals.length;n++){const o=this.faceNormals[n];e.vmult(o,o)}}if(t)for(let n=0;n<s;n++){const o=i[n];o.vadd(t,o)}}pointIsInside(t){const e=this.vertices,s=this.faces,i=this.faceNormals,n=new c;this.getAveragePointLocal(n);for(let o=0;o<this.faces.length;o++){let r=i[o];const a=e[s[o][0]],l=new c;t.vsub(a,l);const h=r.dot(l),u=new c;n.vsub(a,u);const d=r.dot(u);if(h<0&&d>0||h>0&&d<0)return!1}return-1}static project(t,e,s,i,n){const o=t.vertices.length,r=ts;let a=0,l=0;const h=es,u=t.vertices;h.setZero(),k.vectorToLocalFrame(s,i,e,r),k.pointToLocalFrame(s,i,h,h);const d=h.dot(r);l=a=u[0].dot(r);for(let f=1;f<o;f++){const p=u[f].dot(r);p>a&&(a=p),p<l&&(l=p)}if(l-=d,a-=d,l>a){const f=l;l=a,a=f}n[0]=a,n[1]=l}}const Pt=[],_t=[],ts=new c,es=new c;class Tt extends P{constructor(t){super({type:P.types.BOX});this.halfExtents=void 0,this.convexPolyhedronRepresentation=void 0,this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,s=this.halfExtents.z,i=c,n=[new i(-t,-e,-s),new i(t,-e,-s),new i(t,e,-s),new i(-t,e,-s),new i(-t,-e,s),new i(t,-e,s),new i(t,e,s),new i(-t,e,s)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],r=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],a=new ot({vertices:n,faces:o,axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e=new c){return Tt.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,s){const i=t;s.x=1/12*e*(2*i.y*2*i.y+2*i.z*2*i.z),s.y=1/12*e*(2*i.x*2*i.x+2*i.z*2*i.z),s.z=1/12*e*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(t,e){const s=t,i=this.halfExtents;if(s[0].set(i.x,0,0),s[1].set(0,i.y,0),s[2].set(0,0,i.z),s[3].set(-i.x,0,0),s[4].set(0,-i.y,0),s[5].set(0,0,-i.z),e!==void 0)for(let n=0;n!==s.length;n++)e.vmult(s[n],s[n]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,s){const i=this.halfExtents,n=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let o=0;o<n.length;o++)rt.set(n[o][0],n[o][1],n[o][2]),e.vmult(rt,rt),t.vadd(rt,rt),s(rt.x,rt.y,rt.z)}calculateWorldAABB(t,e,s,i){const n=this.halfExtents;K[0].set(n.x,n.y,n.z),K[1].set(-n.x,n.y,n.z),K[2].set(-n.x,-n.y,n.z),K[3].set(-n.x,-n.y,-n.z),K[4].set(n.x,-n.y,-n.z),K[5].set(n.x,n.y,-n.z),K[6].set(-n.x,n.y,-n.z),K[7].set(n.x,-n.y,n.z);const o=K[0];e.vmult(o,o),t.vadd(o,o),i.copy(o),s.copy(o);for(let r=1;r<8;r++){const a=K[r];e.vmult(a,a),t.vadd(a,a);const l=a.x,h=a.y,u=a.z;l>i.x&&(i.x=l),h>i.y&&(i.y=h),u>i.z&&(i.z=u),l<s.x&&(s.x=l),h<s.y&&(s.y=h),u<s.z&&(s.z=u)}}}const rt=new c,K=[new c,new c,new c,new c,new c,new c,new c,new c],Bt={DYNAMIC:1,STATIC:2,KINEMATIC:4},Ft={AWAKE:0,SLEEPY:1,SLEEPING:2};class F extends Ut{constructor(t={}){super();this.id=void 0,this.index=void 0,this.world=void 0,this.preStep=void 0,this.postStep=void 0,this.vlambda=void 0,this.collisionFilterGroup=void 0,this.collisionFilterMask=void 0,this.collisionResponse=void 0,this.position=void 0,this.previousPosition=void 0,this.interpolatedPosition=void 0,this.initPosition=void 0,this.velocity=void 0,this.initVelocity=void 0,this.force=void 0,this.mass=void 0,this.invMass=void 0,this.material=void 0,this.linearDamping=void 0,this.type=void 0,this.allowSleep=void 0,this.sleepState=void 0,this.sleepSpeedLimit=void 0,this.sleepTimeLimit=void 0,this.timeLastSleepy=void 0,this.wakeUpAfterNarrowphase=void 0,this.torque=void 0,this.quaternion=void 0,this.initQuaternion=void 0,this.previousQuaternion=void 0,this.interpolatedQuaternion=void 0,this.angularVelocity=void 0,this.initAngularVelocity=void 0,this.shapes=void 0,this.shapeOffsets=void 0,this.shapeOrientations=void 0,this.inertia=void 0,this.invInertia=void 0,this.invInertiaWorld=void 0,this.invMassSolve=void 0,this.invInertiaSolve=void 0,this.invInertiaWorldSolve=void 0,this.fixedRotation=void 0,this.angularDamping=void 0,this.linearFactor=void 0,this.angularFactor=void 0,this.aabb=void 0,this.aabbNeedsUpdate=void 0,this.boundingRadius=void 0,this.wlambda=void 0,this.isTrigger=void 0,this.id=F.idCounter++,this.index=-1,this.world=null,this.preStep=null,this.postStep=null,this.vlambda=new c,this.collisionFilterGroup=typeof t.collisionFilterGroup=="number"?t.collisionFilterGroup:1,this.collisionFilterMask=typeof t.collisionFilterMask=="number"?t.collisionFilterMask:-1,this.collisionResponse=typeof t.collisionResponse=="boolean"?t.collisionResponse:!0,this.position=new c,this.previousPosition=new c,this.interpolatedPosition=new c,this.initPosition=new c,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new c,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new c,this.force=new c;const e=typeof t.mass=="number"?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping=typeof t.linearDamping=="number"?t.linearDamping:.01,this.type=e<=0?F.STATIC:F.DYNAMIC,typeof t.type==typeof F.STATIC&&(this.type=t.type),this.allowSleep=typeof t.allowSleep!="undefined"?t.allowSleep:!0,this.sleepState=F.AWAKE,this.sleepSpeedLimit=typeof t.sleepSpeedLimit!="undefined"?t.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof t.sleepTimeLimit!="undefined"?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new c,this.quaternion=new j,this.initQuaternion=new j,this.previousQuaternion=new j,this.interpolatedQuaternion=new j,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new c,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new c,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new c,this.invInertia=new c,this.invInertiaWorld=new Z,this.invMassSolve=0,this.invInertiaSolve=new c,this.invInertiaWorldSolve=new Z,this.fixedRotation=typeof t.fixedRotation!="undefined"?t.fixedRotation:!1,this.angularDamping=typeof t.angularDamping!="undefined"?t.angularDamping:.01,this.linearFactor=new c(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new c(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new U,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new c,this.isTrigger=Boolean(t.isTrigger),t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=F.AWAKE,this.wakeUpAfterNarrowphase=!1,t===F.SLEEPING&&this.dispatchEvent(F.wakeupEvent)}sleep(){this.sleepState=F.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;e===F.AWAKE&&s<i?(this.sleepState=F.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(F.sleepyEvent)):e===F.SLEEPY&&s>i?this.wakeUp():e===F.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(F.sleepEvent))}}updateSolveMassProperties(){this.sleepState===F.SLEEPING||this.type===F.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e=new c){return t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e=new c){return this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e=new c){return this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e=new c){return this.quaternion.vmult(t,e),e}addShape(t,e,s){const i=new c,n=new j;return e&&i.copy(e),s&&n.copy(s),this.shapes.push(t),this.shapeOffsets.push(i),this.shapeOrientations.push(n),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return e===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,s=t.length;let i=0;for(let n=0;n!==s;n++){const o=t[n];o.updateBoundingSphereRadius();const r=e[n].length(),a=o.boundingSphereRadius;r+a>i&&(i=r+a)}this.boundingRadius=i}updateAABB(){const t=this.shapes,e=this.shapeOffsets,s=this.shapeOrientations,i=t.length,n=ss,o=is,r=this.quaternion,a=this.aabb,l=ns;for(let h=0;h!==i;h++){const u=t[h];r.vmult(e[h],n),n.vadd(this.position,n),r.mult(s[h],o),u.calculateWorldAABB(n,o,l.lowerBound,l.upperBound),h===0?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(!(e.x===e.y&&e.y===e.z&&!t)){const s=os,i=rs;s.setRotationFromQuaternion(this.quaternion),s.transpose(i),s.scale(e,s),s.mmult(i,this.invInertiaWorld)}}applyForce(t,e=new c){if(this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const s=as;e.cross(t,s),this.force.vadd(t,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(t,e=new c){if(this.type!==F.DYNAMIC)return;const s=ls,i=cs;this.vectorToWorldFrame(t,s),this.vectorToWorldFrame(e,i),this.applyForce(s,i)}applyTorque(t){this.type===F.DYNAMIC&&(this.sleepState===F.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e=new c){if(this.type!==F.DYNAMIC)return;this.sleepState===F.SLEEPING&&this.wakeUp();const s=e,i=hs;i.copy(t),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const n=ds;s.cross(t,n),this.invInertiaWorld.vmult(n,n),this.angularVelocity.vadd(n,this.angularVelocity)}applyLocalImpulse(t,e=new c){if(this.type!==F.DYNAMIC)return;const s=us,i=ps;this.vectorToWorldFrame(t,s),this.vectorToWorldFrame(e,i),this.applyImpulse(s,i)}updateMassProperties(){const t=fs;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,s=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Tt.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!s?1/e.x:0,e.y>0&&!s?1/e.y:0,e.z>0&&!s?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const s=new c;return t.vsub(this.position,s),this.angularVelocity.cross(s,e),this.velocity.vadd(e,e),e}integrate(t,e,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===F.DYNAMIC||this.type===F.KINEMATIC)||this.sleepState===F.SLEEPING)return;const i=this.velocity,n=this.angularVelocity,o=this.position,r=this.force,a=this.torque,l=this.quaternion,h=this.invMass,u=this.invInertiaWorld,d=this.linearFactor,f=h*t;i.x+=r.x*f*d.x,i.y+=r.y*f*d.y,i.z+=r.z*f*d.z;const p=u.elements,y=this.angularFactor,m=a.x*y.x,g=a.y*y.y,v=a.z*y.z;n.x+=t*(p[0]*m+p[1]*g+p[2]*v),n.y+=t*(p[3]*m+p[4]*g+p[5]*v),n.z+=t*(p[6]*m+p[7]*g+p[8]*v),o.x+=i.x*t,o.y+=i.y*t,o.z+=i.z*t,l.integrate(this.angularVelocity,t,this.angularFactor,l),e&&(s?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}F.idCounter=0;F.COLLIDE_EVENT_NAME="collide";F.DYNAMIC=Bt.DYNAMIC;F.STATIC=Bt.STATIC;F.KINEMATIC=Bt.KINEMATIC;F.AWAKE=Ft.AWAKE;F.SLEEPY=Ft.SLEEPY;F.SLEEPING=Ft.SLEEPING;F.wakeupEvent={type:"wakeup"};F.sleepyEvent={type:"sleepy"};F.sleepEvent={type:"sleep"};const ss=new c,is=new j,ns=new U,os=new Z,rs=new Z,as=new c,ls=new c,cs=new c,hs=new c,ds=new c,us=new c,ps=new c,fs=new c;class Zt{constructor(){this.world=void 0,this.useBoundingBoxes=void 0,this.dirty=void 0,this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,s){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return!((t.collisionFilterGroup&e.collisionFilterMask)==0||(e.collisionFilterGroup&t.collisionFilterMask)==0||((t.type&F.STATIC)!=0||t.sleepState===F.SLEEPING)&&((e.type&F.STATIC)!=0||e.sleepState===F.SLEEPING))}intersectionTest(t,e,s,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,s,i):this.doBoundingSphereBroadphase(t,e,s,i)}doBoundingSphereBroadphase(t,e,s,i){const n=vs;e.position.vsub(t.position,n);const o=(t.boundingRadius+e.boundingRadius)**2;n.lengthSquared()<o&&(s.push(t),i.push(e))}doBoundingBoxBroadphase(t,e,s,i){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(s.push(t),i.push(e))}makePairsUnique(t,e){const s=ms,i=ys,n=ws,o=t.length;for(let r=0;r!==o;r++)i[r]=t[r],n[r]=e[r];t.length=0,e.length=0;for(let r=0;r!==o;r++){const a=i[r].id,l=n[r].id,h=a<l?a+","+l:l+","+a;s[h]=r,s.keys.push(h)}for(let r=0;r!==s.keys.length;r++){const a=s.keys.pop(),l=s[a];t.push(i[l]),e.push(n[l]),delete s[a]}}setWorld(t){}static boundingSphereCheck(t,e){const s=new c;t.position.vsub(e.position,s);const i=t.shapes[0],n=e.shapes[0];return Math.pow(i.boundingSphereRadius+n.boundingSphereRadius,2)>s.lengthSquared()}aabbQuery(t,e,s){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const vs=new c,ms={keys:[]},ys=[],ws=[];new c;class gs extends Zt{constructor(){super()}collisionPairs(t,e,s){const i=t.bodies,n=i.length;let o,r;for(let a=0;a!==n;a++)for(let l=0;l!==a;l++)o=i[a],r=i[l],!!this.needBroadphaseCollision(o,r)&&this.intersectionTest(o,r,e,s)}aabbQuery(t,e,s=[]){for(let i=0;i<t.bodies.length;i++){const n=t.bodies[i];n.aabbNeedsUpdate&&n.updateAABB(),n.aabb.overlaps(e)&&s.push(n)}return s}}class Lt{constructor(){this.rayFromWorld=void 0,this.rayToWorld=void 0,this.hitNormalWorld=void 0,this.hitPointWorld=void 0,this.hasHit=void 0,this.shape=void 0,this.body=void 0,this.hitFaceIndex=void 0,this.distance=void 0,this.shouldStop=void 0,this.rayFromWorld=new c,this.rayToWorld=new c,this.hitNormalWorld=new c,this.hitPointWorld=new c,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,s,i,n,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(i),this.shape=n,this.body=o,this.distance=r}}let Kt,Qt,Jt,te,ee,se,ie;const Rt={CLOSEST:1,ANY:2,ALL:4};Kt=P.types.SPHERE;Qt=P.types.PLANE;Jt=P.types.BOX;te=P.types.CYLINDER;ee=P.types.CONVEXPOLYHEDRON;se=P.types.HEIGHTFIELD;ie=P.types.TRIMESH;class H{get[Kt](){return this._intersectSphere}get[Qt](){return this._intersectPlane}get[Jt](){return this._intersectBox}get[te](){return this._intersectConvex}get[ee](){return this._intersectConvex}get[se](){return this._intersectHeightfield}get[ie](){return this._intersectTrimesh}constructor(t=new c,e=new c){this.from=void 0,this.to=void 0,this.direction=void 0,this.precision=void 0,this.checkCollisionResponse=void 0,this.skipBackfaces=void 0,this.collisionFilterMask=void 0,this.collisionFilterGroup=void 0,this.mode=void 0,this.result=void 0,this.hasHit=void 0,this.callback=void 0,this.from=t.clone(),this.to=e.clone(),this.direction=new c,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=H.ANY,this.result=new Lt,this.hasHit=!1,this.callback=s=>{}}intersectWorld(t,e){return this.mode=e.mode||H.ANY,this.result=e.result||new Lt,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=typeof e.collisionFilterMask!="undefined"?e.collisionFilterMask:-1,this.collisionFilterGroup=typeof e.collisionFilterGroup!="undefined"?e.collisionFilterGroup:-1,this.checkCollisionResponse=typeof e.checkCollisionResponse!="undefined"?e.checkCollisionResponse:!0,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(ne),qt.length=0,t.broadphase.aabbQuery(t,ne,qt),this.intersectBodies(qt),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!t.collisionResponse||(this.collisionFilterGroup&t.collisionFilterMask)==0||(t.collisionFilterGroup&this.collisionFilterMask)==0)return;const i=xs,n=bs;for(let o=0,r=t.shapes.length;o<r;o++){const a=t.shapes[o];if(!(s&&!a.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[o],n),t.quaternion.vmult(t.shapeOffsets[o],i),i.vadd(t.position,i),this.intersectShape(a,n,i,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let s=0,i=t.length;!this.result.shouldStop&&s<i;s++)this.intersectBody(t[s])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,s,i){const n=this.from;if(Ls(n,this.direction,s)>t.boundingSphereRadius)return;const r=this[t.type];r&&r.call(this,t,e,s,i,t)}_intersectBox(t,e,s,i,n){return this._intersectConvex(t.convexPolyhedronRepresentation,e,s,i,n)}_intersectPlane(t,e,s,i,n){const o=this.from,r=this.to,a=this.direction,l=new c(0,0,1);e.vmult(l,l);const h=new c;o.vsub(s,h);const u=h.dot(l);r.vsub(s,h);const d=h.dot(l);if(u*d>0||o.distanceTo(r)<u)return;const f=l.dot(a);if(Math.abs(f)<this.precision)return;const p=new c,y=new c,m=new c;o.vsub(s,p);const g=-l.dot(p)/f;a.scale(g,y),o.vadd(y,m),this.reportIntersection(l,m,n,i,-1)}getAABB(t){const{lowerBound:e,upperBound:s}=t,i=this.to,n=this.from;e.x=Math.min(i.x,n.x),e.y=Math.min(i.y,n.y),e.z=Math.min(i.z,n.z),s.x=Math.max(i.x,n.x),s.y=Math.max(i.y,n.y),s.z=Math.max(i.z,n.z)}_intersectHeightfield(t,e,s,i,n){t.data,t.elementSize;const o=Es;o.from.copy(this.from),o.to.copy(this.to),k.pointToLocalFrame(s,e,o.from,o.from),k.pointToLocalFrame(s,e,o.to,o.to),o.updateDirection();const r=Cs;let a,l,h,u;a=l=0,h=u=t.data.length-1;const d=new U;o.getAABB(d),t.getIndexOfPosition(d.lowerBound.x,d.lowerBound.y,r,!0),a=Math.max(a,r[0]),l=Math.max(l,r[1]),t.getIndexOfPosition(d.upperBound.x,d.upperBound.y,r,!0),h=Math.min(h,r[0]+1),u=Math.min(u,r[1]+1);for(let f=a;f<h;f++)for(let p=l;p<u;p++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(f,p,d),!!d.overlapsRay(o)){if(t.getConvexTrianglePillar(f,p,!1),k.pointToWorldFrame(s,e,t.pillarOffset,gt),this._intersectConvex(t.pillarConvex,e,gt,i,n,oe),this.result.shouldStop)return;t.getConvexTrianglePillar(f,p,!0),k.pointToWorldFrame(s,e,t.pillarOffset,gt),this._intersectConvex(t.pillarConvex,e,gt,i,n,oe)}}}_intersectSphere(t,e,s,i,n){const o=this.from,r=this.to,a=t.radius,l=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,h=2*((r.x-o.x)*(o.x-s.x)+(r.y-o.y)*(o.y-s.y)+(r.z-o.z)*(o.z-s.z)),u=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2-a**2,d=h**2-4*l*u,f=Ss,p=zs;if(!(d<0))if(d===0)o.lerp(r,d,f),f.vsub(s,p),p.normalize(),this.reportIntersection(p,f,n,i,-1);else{const y=(-h-Math.sqrt(d))/(2*l),m=(-h+Math.sqrt(d))/(2*l);if(y>=0&&y<=1&&(o.lerp(r,y,f),f.vsub(s,p),p.normalize(),this.reportIntersection(p,f,n,i,-1)),this.result.shouldStop)return;m>=0&&m<=1&&(o.lerp(r,m,f),f.vsub(s,p),p.normalize(),this.reportIntersection(p,f,n,i,-1))}}_intersectConvex(t,e,s,i,n,o){const r=Is,a=re,l=o&&o.faceList||null,h=t.faces,u=t.vertices,d=t.faceNormals,f=this.direction,p=this.from,y=this.to,m=p.distanceTo(y),g=l?l.length:h.length,v=this.result;for(let b=0;!v.shouldStop&&b<g;b++){const E=l?l[b]:b,N=h[E],M=d[E],T=e,C=s;a.copy(u[N[0]]),T.vmult(a,a),a.vadd(C,a),a.vsub(p,a),T.vmult(M,r);const S=f.dot(r);if(Math.abs(S)<this.precision)continue;const A=r.dot(a)/S;if(!(A<0)){f.scale(A,X),X.vadd(p,X),$.copy(u[N[0]]),T.vmult($,$),C.vadd($,$);for(let B=1;!v.shouldStop&&B<N.length-1;B++){Q.copy(u[N[B]]),J.copy(u[N[B+1]]),T.vmult(Q,Q),T.vmult(J,J),C.vadd(Q,Q),C.vadd(J,J);const _=X.distanceTo(p);!(H.pointInTriangle(X,$,Q,J)||H.pointInTriangle(X,Q,$,J))||_>m||this.reportIntersection(r,X,n,i,E)}}}}_intersectTrimesh(t,e,s,i,n,o){const r=Ns,a=Bs,l=Fs,h=re,u=Ms,d=As,f=Ps,p=Ts,y=_s,m=t.indices;t.vertices;const g=this.from,v=this.to,b=this.direction;l.position.copy(s),l.quaternion.copy(e),k.vectorToLocalFrame(s,e,b,u),k.pointToLocalFrame(s,e,g,d),k.pointToLocalFrame(s,e,v,f),f.x*=t.scale.x,f.y*=t.scale.y,f.z*=t.scale.z,d.x*=t.scale.x,d.y*=t.scale.y,d.z*=t.scale.z,f.vsub(d,u),u.normalize();const E=d.distanceSquared(f);t.tree.rayQuery(this,l,a);for(let N=0,M=a.length;!this.result.shouldStop&&N!==M;N++){const T=a[N];t.getNormal(T,r),t.getVertex(m[T*3],$),$.vsub(d,h);const C=u.dot(r),S=r.dot(h)/C;if(S<0)continue;u.scale(S,X),X.vadd(d,X),t.getVertex(m[T*3+1],Q),t.getVertex(m[T*3+2],J);const A=X.distanceSquared(d);!(H.pointInTriangle(X,Q,$,J)||H.pointInTriangle(X,$,Q,J))||A>E||(k.vectorToWorldFrame(e,r,y),k.pointToWorldFrame(s,e,X,p),this.reportIntersection(y,p,n,i,T))}a.length=0}reportIntersection(t,e,s,i,n){const o=this.from,r=this.to,a=o.distanceTo(e),l=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(l.hitFaceIndex=typeof n!="undefined"?n:-1,this.mode){case H.ALL:this.hasHit=!0,l.set(o,r,t,e,s,i,a),l.hasHit=!0,this.callback(l);break;case H.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(o,r,t,e,s,i,a));break;case H.ANY:this.hasHit=!0,l.hasHit=!0,l.set(o,r,t,e,s,i,a),l.shouldStop=!0;break}}static pointInTriangle(t,e,s,i){i.vsub(e,at),s.vsub(e,ut),t.vsub(e,Ot);const n=at.dot(at),o=at.dot(ut),r=at.dot(Ot),a=ut.dot(ut),l=ut.dot(Ot);let h,u;return(h=a*r-o*l)>=0&&(u=n*l-o*r)>=0&&h+u<n*a-o*o}}H.CLOSEST=Rt.CLOSEST;H.ANY=Rt.ANY;H.ALL=Rt.ALL;const ne=new U,qt=[],ut=new c,Ot=new c,xs=new c,bs=new j,X=new c,$=new c,Q=new c,J=new c,oe={faceList:[0]},gt=new c,Es=new H,Cs=[],Ss=new c,zs=new c,Is=new c,re=new c,Ns=new c,Ms=new c,As=new c,Ps=new c,_s=new c,Ts=new c;new U;const Bs=[],Fs=new k,at=new c,xt=new c;function Ls(O,t,e){e.vsub(O,at);const s=at.dot(t);return t.scale(s,xt),xt.vadd(O,xt),e.distanceTo(xt)}class pt extends Zt{static checkBounds(t,e,s){let i,n;s===0?(i=t.position.x,n=e.position.x):s===1?(i=t.position.y,n=e.position.y):s===2&&(i=t.position.z,n=e.position.z);const o=t.boundingRadius,r=e.boundingRadius,a=i+o;return n-r<a}static insertionSortX(t){for(let e=1,s=t.length;e<s;e++){const i=t[e];let n;for(n=e-1;n>=0&&!(t[n].aabb.lowerBound.x<=i.aabb.lowerBound.x);n--)t[n+1]=t[n];t[n+1]=i}return t}static insertionSortY(t){for(let e=1,s=t.length;e<s;e++){const i=t[e];let n;for(n=e-1;n>=0&&!(t[n].aabb.lowerBound.y<=i.aabb.lowerBound.y);n--)t[n+1]=t[n];t[n+1]=i}return t}static insertionSortZ(t){for(let e=1,s=t.length;e<s;e++){const i=t[e];let n;for(n=e-1;n>=0&&!(t[n].aabb.lowerBound.z<=i.aabb.lowerBound.z);n--)t[n+1]=t[n];t[n+1]=i}return t}constructor(t){super();this.axisList=void 0,this.world=void 0,this.axisIndex=void 0,this._addBodyHandler=void 0,this._removeBodyHandler=void 0,this.axisList=[],this.world=null,this.axisIndex=0;const e=this.axisList;this._addBodyHandler=s=>{e.push(s.body)},this._removeBodyHandler=s=>{const i=e.indexOf(s.body);i!==-1&&e.splice(i,1)},t&&this.setWorld(t)}setWorld(t){this.axisList.length=0;for(let e=0;e<t.bodies.length;e++)this.axisList.push(t.bodies[e]);t.removeEventListener("addBody",this._addBodyHandler),t.removeEventListener("removeBody",this._removeBodyHandler),t.addEventListener("addBody",this._addBodyHandler),t.addEventListener("removeBody",this._removeBodyHandler),this.world=t,this.dirty=!0}collisionPairs(t,e,s){const i=this.axisList,n=i.length,o=this.axisIndex;let r,a;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==n;r++){const l=i[r];for(a=r+1;a<n;a++){const h=i[a];if(!!this.needBroadphaseCollision(l,h)){if(!pt.checkBounds(l,h,o))break;this.intersectionTest(l,h,e,s)}}}}sortList(){const t=this.axisList,e=this.axisIndex,s=t.length;for(let i=0;i!==s;i++){const n=t[i];n.aabbNeedsUpdate&&n.updateAABB()}e===0?pt.insertionSortX(t):e===1?pt.insertionSortY(t):e===2&&pt.insertionSortZ(t)}autoDetectAxis(){let t=0,e=0,s=0,i=0,n=0,o=0;const r=this.axisList,a=r.length,l=1/a;for(let f=0;f!==a;f++){const p=r[f],y=p.position.x;t+=y,e+=y*y;const m=p.position.y;s+=m,i+=m*m;const g=p.position.z;n+=g,o+=g*g}const h=e-t*t*l,u=i-s*s*l,d=o-n*n*l;h>u?h>d?this.axisIndex=0:this.axisIndex=2:u>d?this.axisIndex=1:this.axisIndex=2}aabbQuery(t,e,s=[]){this.dirty&&(this.sortList(),this.dirty=!1);const i=this.axisIndex;let n="x";i===1&&(n="y"),i===2&&(n="z");const o=this.axisList;e.lowerBound[n],e.upperBound[n];for(let r=0;r<o.length;r++){const a=o[r];a.aabbNeedsUpdate&&a.updateAABB(),a.aabb.overlaps(e)&&s.push(a)}return s}}class ae{static defaults(t={},e){for(let s in e)s in t||(t[s]=e[s]);return t}}class le{constructor(){this.spatial=void 0,this.rotational=void 0,this.spatial=new c,this.rotational=new c}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class ft{constructor(t,e,s=-1e6,i=1e6){this.id=void 0,this.minForce=void 0,this.maxForce=void 0,this.bi=void 0,this.bj=void 0,this.si=void 0,this.sj=void 0,this.a=void 0,this.b=void 0,this.eps=void 0,this.jacobianElementA=void 0,this.jacobianElementB=void 0,this.enabled=void 0,this.multiplier=void 0,this.id=ft.idCounter++,this.minForce=s,this.maxForce=i,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new le,this.jacobianElementB=new le,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,s){const i=e,n=t,o=s;this.a=4/(o*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(o*o*n*(1+4*i))}computeB(t,e,s){const i=this.computeGW(),n=this.computeGq(),o=this.computeGiMf();return-n*t-i*e-o*s}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.position,o=i.position;return t.spatial.dot(n)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.velocity,o=i.velocity,r=s.angularVelocity,a=i.angularVelocity;return t.multiplyVectors(n,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.vlambda,o=i.vlambda,r=s.wlambda,a=i.wlambda;return t.multiplyVectors(n,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.force,o=s.torque,r=i.force,a=i.torque,l=s.invMassSolve,h=i.invMassSolve;return n.scale(l,ce),r.scale(h,he),s.invInertiaWorldSolve.vmult(o,de),i.invInertiaWorldSolve.vmult(a,ue),t.multiplyVectors(ce,de)+e.multiplyVectors(he,ue)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.invMassSolve,o=i.invMassSolve,r=s.invInertiaWorldSolve,a=i.invInertiaWorldSolve;let l=n+o;return r.vmult(t.rotational,bt),l+=bt.dot(t.rotational),a.vmult(e.rotational,bt),l+=bt.dot(e.rotational),l}addToWlambda(t){const e=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,n=this.bj,o=Rs;i.vlambda.addScaledVector(i.invMassSolve*t,e.spatial,i.vlambda),n.vlambda.addScaledVector(n.invMassSolve*t,s.spatial,n.vlambda),i.invInertiaWorldSolve.vmult(e.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda),n.invInertiaWorldSolve.vmult(s.rotational,o),n.wlambda.addScaledVector(t,o,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}ft.idCounter=0;const ce=new c,he=new c,de=new c,ue=new c,bt=new c,Rs=new c;class qs extends ft{constructor(t,e,s=1e6){super(t,e,0,s);this.restitution=void 0,this.ri=void 0,this.rj=void 0,this.ni=void 0,this.restitution=0,this.ri=new c,this.rj=new c,this.ni=new c}computeB(t){const e=this.a,s=this.b,i=this.bi,n=this.bj,o=this.ri,r=this.rj,a=Os,l=Vs,h=i.velocity,u=i.angularVelocity;i.force,i.torque;const d=n.velocity,f=n.angularVelocity;n.force,n.torque;const p=ks,y=this.jacobianElementA,m=this.jacobianElementB,g=this.ni;o.cross(g,a),r.cross(g,l),g.negate(y.spatial),a.negate(y.rotational),m.spatial.copy(g),m.rotational.copy(l),p.copy(n.position),p.vadd(r,p),p.vsub(i.position,p),p.vsub(o,p);const v=g.dot(p),b=this.restitution+1,E=b*d.dot(g)-b*h.dot(g)+f.dot(l)-u.dot(a),N=this.computeGiMf();return-v*e-E*s-t*N}getImpactVelocityAlongNormal(){const t=Ws,e=js,s=Hs,i=Ys,n=Gs;return this.bi.position.vadd(this.ri,s),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(s,t),this.bj.getVelocityAtWorldPoint(i,e),t.vsub(e,n),this.ni.dot(n)}}const Os=new c,Vs=new c,ks=new c,Ws=new c,js=new c,Hs=new c,Ys=new c,Gs=new c;new c;new c;new c;new c;new c;new c;class pe extends ft{constructor(t,e,s){super(t,e,-s,s);this.ri=void 0,this.rj=void 0,this.t=void 0,this.ri=new c,this.rj=new c,this.t=new c}computeB(t){this.a;const e=this.b;this.bi,this.bj;const s=this.ri,i=this.rj,n=Ds,o=Xs,r=this.t;s.cross(r,n),i.cross(r,o);const a=this.jacobianElementA,l=this.jacobianElementB;r.negate(a.spatial),n.negate(a.rotational),l.spatial.copy(r),l.rotational.copy(o);const h=this.computeGW(),u=this.computeGiMf();return-h*e-t*u}}const Ds=new c,Xs=new c;class Et{constructor(t,e,s){this.id=void 0,this.materials=void 0,this.friction=void 0,this.restitution=void 0,this.contactEquationStiffness=void 0,this.contactEquationRelaxation=void 0,this.frictionEquationStiffness=void 0,this.frictionEquationRelaxation=void 0,s=ae.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Et.idCounter++,this.materials=[t,e],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}Et.idCounter=0;class Ct{constructor(t={}){this.name=void 0,this.id=void 0,this.friction=void 0,this.restitution=void 0;let e="";typeof t=="string"&&(e=t,t={}),this.name=e,this.id=Ct.idCounter++,this.friction=typeof t.friction!="undefined"?t.friction:-1,this.restitution=typeof t.restitution!="undefined"?t.restitution:-1}}Ct.idCounter=0;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new H;new c;new c;new c(1,0,0),new c(0,1,0),new c(0,0,1);new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;new c;class Mn extends ot{constructor(t=1,e=1,s=1,i=8){if(t<0)throw new Error("The cylinder radiusTop cannot be negative.");if(e<0)throw new Error("The cylinder radiusBottom cannot be negative.");const n=i,o=[],r=[],a=[],l=[],h=[],u=Math.cos,d=Math.sin;o.push(new c(-e*d(0),-s*.5,e*u(0))),l.push(0),o.push(new c(-t*d(0),s*.5,t*u(0))),h.push(1);for(let p=0;p<n;p++){const y=2*Math.PI/n*(p+1),m=2*Math.PI/n*(p+.5);p<n-1?(o.push(new c(-e*d(y),-s*.5,e*u(y))),l.push(2*p+2),o.push(new c(-t*d(y),s*.5,t*u(y))),h.push(2*p+3),a.push([2*p,2*p+1,2*p+3,2*p+2])):a.push([2*p,2*p+1,1,0]),(n%2==1||p<n/2)&&r.push(new c(-d(m),0,u(m)))}a.push(l),r.push(new c(0,1,0));const f=[];for(let p=0;p<h.length;p++)f.push(h[h.length-p-1]);a.push(f);super({vertices:o,faces:a,axes:r});this.radiusTop=void 0,this.radiusBottom=void 0,this.height=void 0,this.numSegments=void 0,this.type=P.types.CYLINDER,this.radiusTop=t,this.radiusBottom=e,this.height=s,this.numSegments=i}}new c;class An extends P{constructor(t,e={}){e=ae.defaults(e,{maxValue:null,minValue:null,elementSize:1});super({type:P.types.HEIGHTFIELD});this.data=void 0,this.maxValue=void 0,this.minValue=void 0,this.elementSize=void 0,this.cacheEnabled=void 0,this.pillarConvex=void 0,this.pillarOffset=void 0,this._cachedPillars=void 0,this.data=t,this.maxValue=e.maxValue,this.minValue=e.minValue,this.elementSize=e.elementSize,e.minValue===null&&this.updateMinValue(),e.maxValue===null&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new ot,this.pillarOffset=new c,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){const t=this.data;let e=t[0][0];for(let s=0;s!==t.length;s++)for(let i=0;i!==t[s].length;i++){const n=t[s][i];n<e&&(e=n)}this.minValue=e}updateMaxValue(){const t=this.data;let e=t[0][0];for(let s=0;s!==t.length;s++)for(let i=0;i!==t[s].length;i++){const n=t[s][i];n>e&&(e=n)}this.maxValue=e}setHeightValueAtIndex(t,e,s){const i=this.data;i[t][e]=s,this.clearCachedConvexTrianglePillar(t,e,!1),t>0&&(this.clearCachedConvexTrianglePillar(t-1,e,!0),this.clearCachedConvexTrianglePillar(t-1,e,!1)),e>0&&(this.clearCachedConvexTrianglePillar(t,e-1,!0),this.clearCachedConvexTrianglePillar(t,e-1,!1)),e>0&&t>0&&this.clearCachedConvexTrianglePillar(t-1,e-1,!0)}getRectMinMax(t,e,s,i,n=[]){const o=this.data;let r=this.minValue;for(let a=t;a<=s;a++)for(let l=e;l<=i;l++){const h=o[a][l];h>r&&(r=h)}n[0]=this.minValue,n[1]=r}getIndexOfPosition(t,e,s,i){const n=this.elementSize,o=this.data;let r=Math.floor(t/n),a=Math.floor(e/n);return s[0]=r,s[1]=a,i&&(r<0&&(r=0),a<0&&(a=0),r>=o.length-1&&(r=o.length-1),a>=o[0].length-1&&(a=o[0].length-1)),!(r<0||a<0||r>=o.length-1||a>=o[0].length-1)}getTriangleAt(t,e,s,i,n,o){const r=fe;this.getIndexOfPosition(t,e,r,s);let a=r[0],l=r[1];const h=this.data;s&&(a=Math.min(h.length-2,Math.max(0,a)),l=Math.min(h[0].length-2,Math.max(0,l)));const u=this.elementSize,d=(t/u-a)**2+(e/u-l)**2,f=(t/u-(a+1))**2+(e/u-(l+1))**2,p=d>f;return this.getTriangle(a,l,p,i,n,o),p}getNormalAt(t,e,s,i){const n=Ks,o=Qs,r=Js,a=ti,l=ei;this.getTriangleAt(t,e,s,n,o,r),o.vsub(n,a),r.vsub(n,l),a.cross(l,i),i.normalize()}getAabbAtIndex(t,e,{lowerBound:s,upperBound:i}){const n=this.data,o=this.elementSize;s.set(t*o,e*o,n[t][e]),i.set((t+1)*o,(e+1)*o,n[t+1][e+1])}getHeightAt(t,e,s){const i=this.data,n=Us,o=$s,r=Zs,a=fe;this.getIndexOfPosition(t,e,a,s);let l=a[0],h=a[1];s&&(l=Math.min(i.length-2,Math.max(0,l)),h=Math.min(i[0].length-2,Math.max(0,h)));const u=this.getTriangleAt(t,e,s,n,o,r);si(t,e,n.x,n.y,o.x,o.y,r.x,r.y,ve);const d=ve;return u?i[l+1][h+1]*d.x+i[l][h+1]*d.y+i[l+1][h]*d.z:i[l][h]*d.x+i[l+1][h]*d.y+i[l][h+1]*d.z}getCacheConvexTrianglePillarKey(t,e,s){return t+"_"+e+"_"+(s?1:0)}getCachedConvexTrianglePillar(t,e,s){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t,e,s)]}setCachedConvexTrianglePillar(t,e,s,i,n){this._cachedPillars[this.getCacheConvexTrianglePillarKey(t,e,s)]={convex:i,offset:n}}clearCachedConvexTrianglePillar(t,e,s){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t,e,s)]}getTriangle(t,e,s,i,n,o){const r=this.data,a=this.elementSize;s?(i.set((t+1)*a,(e+1)*a,r[t+1][e+1]),n.set(t*a,(e+1)*a,r[t][e+1]),o.set((t+1)*a,e*a,r[t+1][e])):(i.set(t*a,e*a,r[t][e]),n.set((t+1)*a,e*a,r[t+1][e]),o.set(t*a,(e+1)*a,r[t][e+1]))}getConvexTrianglePillar(t,e,s){let i=this.pillarConvex,n=this.pillarOffset;if(this.cacheEnabled){const u=this.getCachedConvexTrianglePillar(t,e,s);if(u){this.pillarConvex=u.convex,this.pillarOffset=u.offset;return}i=new ot,n=new c,this.pillarConvex=i,this.pillarOffset=n}const o=this.data,r=this.elementSize,a=i.faces;i.vertices.length=6;for(let u=0;u<6;u++)i.vertices[u]||(i.vertices[u]=new c);a.length=5;for(let u=0;u<5;u++)a[u]||(a[u]=[]);const l=i.vertices,h=(Math.min(o[t][e],o[t+1][e],o[t][e+1],o[t+1][e+1])-this.minValue)/2+this.minValue;s?(n.set((t+.75)*r,(e+.75)*r,h),l[0].set(.25*r,.25*r,o[t+1][e+1]-h),l[1].set(-.75*r,.25*r,o[t][e+1]-h),l[2].set(.25*r,-.75*r,o[t+1][e]-h),l[3].set(.25*r,.25*r,-Math.abs(h)-1),l[4].set(-.75*r,.25*r,-Math.abs(h)-1),l[5].set(.25*r,-.75*r,-Math.abs(h)-1),a[0][0]=0,a[0][1]=1,a[0][2]=2,a[1][0]=5,a[1][1]=4,a[1][2]=3,a[2][0]=2,a[2][1]=5,a[2][2]=3,a[2][3]=0,a[3][0]=3,a[3][1]=4,a[3][2]=1,a[3][3]=0,a[4][0]=1,a[4][1]=4,a[4][2]=5,a[4][3]=2):(n.set((t+.25)*r,(e+.25)*r,h),l[0].set(-.25*r,-.25*r,o[t][e]-h),l[1].set(.75*r,-.25*r,o[t+1][e]-h),l[2].set(-.25*r,.75*r,o[t][e+1]-h),l[3].set(-.25*r,-.25*r,-Math.abs(h)-1),l[4].set(.75*r,-.25*r,-Math.abs(h)-1),l[5].set(-.25*r,.75*r,-Math.abs(h)-1),a[0][0]=0,a[0][1]=1,a[0][2]=2,a[1][0]=5,a[1][1]=4,a[1][2]=3,a[2][0]=0,a[2][1]=2,a[2][2]=5,a[2][3]=3,a[3][0]=1,a[3][1]=0,a[3][2]=3,a[3][3]=4,a[4][0]=4,a[4][1]=5,a[4][2]=2,a[4][3]=1),i.computeNormals(),i.computeEdges(),i.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(t,e,s,i,n)}calculateLocalInertia(t,e=new c){return e.set(0,0,0),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,s,i){s.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),i.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){const t=this.data,e=this.elementSize;this.boundingSphereRadius=new c(t.length*e,t[0].length*e,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(t,e){const{x:s,z:i,y:n}=e,o=document.createElement("canvas");o.width=t.width,o.height=t.height;const r=o.getContext("2d");r.drawImage(t,0,0);const a=r.getImageData(0,0,t.width,t.height),l=this.data;l.length=0,this.elementSize=Math.abs(s)/a.width;for(let h=0;h<a.height;h++){const u=[];for(let d=0;d<a.width;d++){const f=a.data[(h*a.height+d)*4],p=a.data[(h*a.height+d)*4+1],y=a.data[(h*a.height+d)*4+2],m=(f+p+y)/4/255*i;s<0?u.push(m):u.unshift(m)}n<0?l.unshift(u):l.push(u)}this.updateMaxValue(),this.updateMinValue(),this.update()}}const fe=[],ve=new c,Us=new c,$s=new c,Zs=new c,Ks=new c,Qs=new c,Js=new c,ti=new c,ei=new c;function si(O,t,e,s,i,n,o,r,a){a.x=((n-r)*(O-o)+(o-i)*(t-r))/((n-r)*(e-o)+(o-i)*(s-r)),a.y=((r-s)*(O-o)+(e-o)*(t-r))/((n-r)*(e-o)+(o-i)*(s-r)),a.z=1-a.x-a.y}new c;new U;new c;new U;new c;new c;new c;new c;new c;new c;new c;new U;new c;new k;new U;class ii{constructor(){this.equations=void 0,this.equations=[]}solve(t,e){return 0}addEquation(t){t.enabled&&!t.bi.isTrigger&&!t.bj.isTrigger&&this.equations.push(t)}removeEquation(t){const e=this.equations,s=e.indexOf(t);s!==-1&&e.splice(s,1)}removeAllEquations(){this.equations.length=0}}class ni extends ii{constructor(){super();this.iterations=void 0,this.tolerance=void 0,this.iterations=10,this.tolerance=1e-7}solve(t,e){let s=0;const i=this.iterations,n=this.tolerance*this.tolerance,o=this.equations,r=o.length,a=e.bodies,l=a.length,h=t;let u,d,f,p,y,m;if(r!==0)for(let E=0;E!==l;E++)a[E].updateSolveMassProperties();const g=ri,v=ai,b=oi;g.length=r,v.length=r,b.length=r;for(let E=0;E!==r;E++){const N=o[E];b[E]=0,v[E]=N.computeB(h),g[E]=1/N.computeC()}if(r!==0){for(let M=0;M!==l;M++){const T=a[M],C=T.vlambda,S=T.wlambda;C.set(0,0,0),S.set(0,0,0)}for(s=0;s!==i;s++){p=0;for(let M=0;M!==r;M++){const T=o[M];u=v[M],d=g[M],m=b[M],y=T.computeGWlambda(),f=d*(u-y-T.eps*m),m+f<T.minForce?f=T.minForce-m:m+f>T.maxForce&&(f=T.maxForce-m),b[M]+=f,p+=f>0?f:-f,T.addToWlambda(f)}if(p*p<n)break}for(let M=0;M!==l;M++){const T=a[M],C=T.velocity,S=T.angularVelocity;T.vlambda.vmul(T.linearFactor,T.vlambda),C.vadd(T.vlambda,C),T.wlambda.vmul(T.angularFactor,T.wlambda),S.vadd(T.wlambda,S)}let E=o.length;const N=1/h;for(;E--;)o[E].multiplier=b[E]*N}return s}}const oi=[],ri=[],ai=[];class li{constructor(){this.objects=[],this.type=Object}release(...t){const e=t.length;for(let s=0;s!==e;s++)this.objects.push(t[s]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){const e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class ci extends li{constructor(...t){super(...t);this.type=c}constructObject(){return new c}}let me,ye,we,ge,xe,be,Ee,Ce,Se,ze,Ie,Ne,Me,Ae,Pe,_e,Te,Be,Fe,Le,Re,qe,Oe,Ve,ke;const W={sphereSphere:P.types.SPHERE,spherePlane:P.types.SPHERE|P.types.PLANE,boxBox:P.types.BOX|P.types.BOX,sphereBox:P.types.SPHERE|P.types.BOX,planeBox:P.types.PLANE|P.types.BOX,convexConvex:P.types.CONVEXPOLYHEDRON,sphereConvex:P.types.SPHERE|P.types.CONVEXPOLYHEDRON,planeConvex:P.types.PLANE|P.types.CONVEXPOLYHEDRON,boxConvex:P.types.BOX|P.types.CONVEXPOLYHEDRON,sphereHeightfield:P.types.SPHERE|P.types.HEIGHTFIELD,boxHeightfield:P.types.BOX|P.types.HEIGHTFIELD,convexHeightfield:P.types.CONVEXPOLYHEDRON|P.types.HEIGHTFIELD,sphereParticle:P.types.PARTICLE|P.types.SPHERE,planeParticle:P.types.PLANE|P.types.PARTICLE,boxParticle:P.types.BOX|P.types.PARTICLE,convexParticle:P.types.PARTICLE|P.types.CONVEXPOLYHEDRON,cylinderCylinder:P.types.CYLINDER,sphereCylinder:P.types.SPHERE|P.types.CYLINDER,planeCylinder:P.types.PLANE|P.types.CYLINDER,boxCylinder:P.types.BOX|P.types.CYLINDER,convexCylinder:P.types.CONVEXPOLYHEDRON|P.types.CYLINDER,heightfieldCylinder:P.types.HEIGHTFIELD|P.types.CYLINDER,particleCylinder:P.types.PARTICLE|P.types.CYLINDER,sphereTrimesh:P.types.SPHERE|P.types.TRIMESH,planeTrimesh:P.types.PLANE|P.types.TRIMESH};me=W.sphereSphere;ye=W.spherePlane;we=W.boxBox;ge=W.sphereBox;xe=W.planeBox;be=W.convexConvex;Ee=W.sphereConvex;Ce=W.planeConvex;Se=W.boxConvex;ze=W.sphereHeightfield;Ie=W.boxHeightfield;Ne=W.convexHeightfield;Me=W.sphereParticle;Ae=W.planeParticle;Pe=W.boxParticle;_e=W.convexParticle;Te=W.cylinderCylinder;Be=W.sphereCylinder;Fe=W.planeCylinder;Le=W.boxCylinder;Re=W.convexCylinder;qe=W.heightfieldCylinder;Oe=W.particleCylinder;Ve=W.sphereTrimesh;ke=W.planeTrimesh;class hi{get[me](){return this.sphereSphere}get[ye](){return this.spherePlane}get[we](){return this.boxBox}get[ge](){return this.sphereBox}get[xe](){return this.planeBox}get[be](){return this.convexConvex}get[Ee](){return this.sphereConvex}get[Ce](){return this.planeConvex}get[Se](){return this.boxConvex}get[ze](){return this.sphereHeightfield}get[Ie](){return this.boxHeightfield}get[Ne](){return this.convexHeightfield}get[Me](){return this.sphereParticle}get[Ae](){return this.planeParticle}get[Pe](){return this.boxParticle}get[_e](){return this.convexParticle}get[Te](){return this.convexConvex}get[Be](){return this.sphereConvex}get[Fe](){return this.planeConvex}get[Le](){return this.boxConvex}get[Re](){return this.convexConvex}get[qe](){return this.heightfieldCylinder}get[Oe](){return this.particleCylinder}get[Ve](){return this.sphereTrimesh}get[ke](){return this.planeTrimesh}constructor(t){this.contactPointPool=void 0,this.frictionEquationPool=void 0,this.result=void 0,this.frictionResult=void 0,this.v3pool=void 0,this.world=void 0,this.currentContactMaterial=void 0,this.enableFrictionReduction=void 0,this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new ci,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,s,i,n,o){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=t,r.bj=e):r=new qs(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&s.collisionResponse&&i.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=s.material||t.material,h=i.material||e.material;return l&&h&&l.restitution>=0&&h.restitution>=0&&(r.restitution=l.restitution*h.restitution),r.si=n||s,r.sj=o||i,r}createFrictionEquationsFromContact(t,e){const s=t.bi,i=t.bj,n=t.si,o=t.sj,r=this.world,a=this.currentContactMaterial;let l=a.friction;const h=n.material||s.material,u=o.material||i.material;if(h&&u&&h.friction>=0&&u.friction>=0&&(l=h.friction*u.friction),l>0){const d=l*r.gravity.length();let f=s.invMass+i.invMass;f>0&&(f=1/f);const p=this.frictionEquationPool,y=p.length?p.pop():new pe(s,i,d*f),m=p.length?p.pop():new pe(s,i,d*f);return y.bi=m.bi=s,y.bj=m.bj=i,y.minForce=m.minForce=-d*f,y.maxForce=m.maxForce=d*f,y.ri.copy(t.ri),y.rj.copy(t.rj),m.ri.copy(t.ri),m.rj.copy(t.rj),t.ni.tangents(y.t,m.t),y.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),m.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),y.enabled=m.enabled=t.enabled,e.push(y,m),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||t===1)return;const s=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];lt.setZero(),ht.setZero(),dt.setZero();const n=e.bi;e.bj;for(let r=0;r!==t;r++)e=this.result[this.result.length-1-r],e.bi!==n?(lt.vadd(e.ni,lt),ht.vadd(e.ri,ht),dt.vadd(e.rj,dt)):(lt.vsub(e.ni,lt),ht.vadd(e.rj,ht),dt.vadd(e.ri,dt));const o=1/t;ht.scale(o,s.ri),dt.scale(o,s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj),lt.normalize(),lt.tangents(s.t,i.t)}getContacts(t,e,s,i,n,o,r){this.contactPointPool=n,this.frictionEquationPool=r,this.result=i,this.frictionResult=o;const a=pi,l=fi,h=di,u=ui;for(let d=0,f=t.length;d!==f;d++){const p=t[d],y=e[d];let m=null;p.material&&y.material&&(m=s.getContactMaterial(p.material,y.material)||null);const g=p.type&F.KINEMATIC&&y.type&F.STATIC||p.type&F.STATIC&&y.type&F.KINEMATIC||p.type&F.KINEMATIC&&y.type&F.KINEMATIC;for(let v=0;v<p.shapes.length;v++){p.quaternion.mult(p.shapeOrientations[v],a),p.quaternion.vmult(p.shapeOffsets[v],h),h.vadd(p.position,h);const b=p.shapes[v];for(let E=0;E<y.shapes.length;E++){y.quaternion.mult(y.shapeOrientations[E],l),y.quaternion.vmult(y.shapeOffsets[E],u),u.vadd(y.position,u);const N=y.shapes[E];if(!(b.collisionFilterMask&N.collisionFilterGroup&&N.collisionFilterMask&b.collisionFilterGroup)||h.distanceTo(u)>b.boundingSphereRadius+N.boundingSphereRadius)continue;let M=null;b.material&&N.material&&(M=s.getContactMaterial(b.material,N.material)||null),this.currentContactMaterial=M||m||s.defaultContactMaterial;const T=b.type|N.type,C=this[T];if(C){let S=!1;b.type<N.type?S=C.call(this,b,N,h,u,a,l,p,y,b,N,g):S=C.call(this,N,b,u,h,l,a,y,p,b,N,g),S&&g&&(s.shapeOverlapKeeper.set(b.id,N.id),s.bodyOverlapKeeper.set(p.id,y.id))}}}}}sphereSphere(t,e,s,i,n,o,r,a,l,h,u){if(u)return s.distanceSquared(i)<(t.radius+e.radius)**2;const d=this.createContactEquation(r,a,t,e,l,h);i.vsub(s,d.ni),d.ni.normalize(),d.ri.copy(d.ni),d.rj.copy(d.ni),d.ri.scale(t.radius,d.ri),d.rj.scale(-e.radius,d.rj),d.ri.vadd(s,d.ri),d.ri.vsub(r.position,d.ri),d.rj.vadd(i,d.rj),d.rj.vsub(a.position,d.rj),this.result.push(d),this.createFrictionEquationsFromContact(d,this.frictionResult)}spherePlane(t,e,s,i,n,o,r,a,l,h,u){const d=this.createContactEquation(r,a,t,e,l,h);if(d.ni.set(0,0,1),o.vmult(d.ni,d.ni),d.ni.negate(d.ni),d.ni.normalize(),d.ni.scale(t.radius,d.ri),s.vsub(i,St),d.ni.scale(d.ni.dot(St),We),St.vsub(We,d.rj),-St.dot(d.ni)<=t.radius){if(u)return!0;const f=d.ri,p=d.rj;f.vadd(s,f),f.vsub(r.position,f),p.vadd(i,p),p.vsub(a.position,p),this.result.push(d),this.createFrictionEquationsFromContact(d,this.frictionResult)}}boxBox(t,e,s,i,n,o,r,a,l,h,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,s,i,n,o,r,a,t,e,u)}sphereBox(t,e,s,i,n,o,r,a,l,h,u){const d=this.v3pool,f=ki;s.vsub(i,zt),e.getSideNormals(f,o);const p=t.radius;let y=!1;const m=ji,g=Hi,v=Yi;let b=null,E=0,N=0,M=0,T=null;for(let x=0,R=f.length;x!==R&&y===!1;x++){const q=qi;q.copy(f[x]);const V=q.length();q.normalize();const D=zt.dot(q);if(D<V+p&&D>0){const G=Oi,L=Vi;G.copy(f[(x+1)%3]),L.copy(f[(x+2)%3]);const ct=G.length(),wt=L.length();G.normalize(),L.normalize();const It=zt.dot(G),Nt=zt.dot(L);if(It<ct&&It>-ct&&Nt<wt&&Nt>-wt){const kt=Math.abs(D-V-p);if((T===null||kt<T)&&(T=kt,N=It,M=Nt,b=V,m.copy(q),g.copy(G),v.copy(L),E++,u))return!0}}}if(E){y=!0;const x=this.createContactEquation(r,a,t,e,l,h);m.scale(-p,x.ri),x.ni.copy(m),x.ni.negate(x.ni),m.scale(b,m),g.scale(N,g),m.vadd(g,m),v.scale(M,v),m.vadd(v,x.rj),x.ri.vadd(s,x.ri),x.ri.vsub(r.position,x.ri),x.rj.vadd(i,x.rj),x.rj.vsub(a.position,x.rj),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}let C=d.get();const S=Wi;for(let x=0;x!==2&&!y;x++)for(let R=0;R!==2&&!y;R++)for(let q=0;q!==2&&!y;q++)if(C.set(0,0,0),x?C.vadd(f[0],C):C.vsub(f[0],C),R?C.vadd(f[1],C):C.vsub(f[1],C),q?C.vadd(f[2],C):C.vsub(f[2],C),i.vadd(C,S),S.vsub(s,S),S.lengthSquared()<p*p){if(u)return!0;y=!0;const V=this.createContactEquation(r,a,t,e,l,h);V.ri.copy(S),V.ri.normalize(),V.ni.copy(V.ri),V.ri.scale(p,V.ri),V.rj.copy(C),V.ri.vadd(s,V.ri),V.ri.vsub(r.position,V.ri),V.rj.vadd(i,V.rj),V.rj.vsub(a.position,V.rj),this.result.push(V),this.createFrictionEquationsFromContact(V,this.frictionResult)}d.release(C),C=null;const A=d.get(),B=d.get(),_=d.get(),w=d.get(),z=d.get(),I=f.length;for(let x=0;x!==I&&!y;x++)for(let R=0;R!==I&&!y;R++)if(x%3!=R%3){f[R].cross(f[x],A),A.normalize(),f[x].vadd(f[R],B),_.copy(s),_.vsub(B,_),_.vsub(i,_);const q=_.dot(A);A.scale(q,w);let V=0;for(;V===x%3||V===R%3;)V++;z.copy(s),z.vsub(w,z),z.vsub(B,z),z.vsub(i,z);const D=Math.abs(q),G=z.length();if(D<f[V].length()&&G<p){if(u)return!0;y=!0;const L=this.createContactEquation(r,a,t,e,l,h);B.vadd(w,L.rj),L.rj.copy(L.rj),z.negate(L.ni),L.ni.normalize(),L.ri.copy(L.rj),L.ri.vadd(i,L.ri),L.ri.vsub(s,L.ri),L.ri.normalize(),L.ri.scale(p,L.ri),L.ri.vadd(s,L.ri),L.ri.vsub(r.position,L.ri),L.rj.vadd(i,L.rj),L.rj.vsub(a.position,L.rj),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult)}}d.release(A,B,_,w,z)}planeBox(t,e,s,i,n,o,r,a,l,h,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,s,i,n,o,r,a,t,e,u)}convexConvex(t,e,s,i,n,o,r,a,l,h,u,d,f){const p=rn;if(!(s.distanceTo(i)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,s,n,i,o,p,d,f)){const y=[],m=an;t.clipAgainstHull(s,n,e,i,o,p,-100,100,y);let g=0;for(let v=0;v!==y.length;v++){if(u)return!0;const b=this.createContactEquation(r,a,t,e,l,h),E=b.ri,N=b.rj;p.negate(b.ni),y[v].normal.negate(m),m.scale(y[v].depth,m),y[v].point.vadd(m,E),N.copy(y[v].point),E.vsub(s,E),N.vsub(i,N),E.vadd(s,E),E.vsub(r.position,E),N.vadd(i,N),N.vsub(a.position,N),this.result.push(b),g++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(b,this.frictionResult)}this.enableFrictionReduction&&g&&this.createFrictionFromAverage(g)}}sphereConvex(t,e,s,i,n,o,r,a,l,h,u){const d=this.v3pool;s.vsub(i,Gi);const f=e.faceNormals,p=e.faces,y=e.vertices,m=t.radius;let g=!1;for(let v=0;v!==y.length;v++){const b=y[v],E=$i;o.vmult(b,E),i.vadd(E,E);const N=Ui;if(E.vsub(s,N),N.lengthSquared()<m*m){if(u)return!0;g=!0;const M=this.createContactEquation(r,a,t,e,l,h);M.ri.copy(N),M.ri.normalize(),M.ni.copy(M.ri),M.ri.scale(m,M.ri),E.vsub(i,M.rj),M.ri.vadd(s,M.ri),M.ri.vsub(r.position,M.ri),M.rj.vadd(i,M.rj),M.rj.vsub(a.position,M.rj),this.result.push(M),this.createFrictionEquationsFromContact(M,this.frictionResult);return}}for(let v=0,b=p.length;v!==b&&g===!1;v++){const E=f[v],N=p[v],M=Zi;o.vmult(E,M);const T=Ki;o.vmult(y[N[0]],T),T.vadd(i,T);const C=Qi;M.scale(-m,C),s.vadd(C,C);const S=Ji;C.vsub(T,S);const A=S.dot(M),B=tn;if(s.vsub(T,B),A<0&&B.dot(M)>0){const _=[];for(let w=0,z=N.length;w!==z;w++){const I=d.get();o.vmult(y[N[w]],I),i.vadd(I,I),_.push(I)}if(Ri(_,M,s)){if(u)return!0;g=!0;const w=this.createContactEquation(r,a,t,e,l,h);M.scale(-m,w.ri),M.negate(w.ni);const z=d.get();M.scale(-A,z);const I=d.get();M.scale(-m,I),s.vsub(i,w.rj),w.rj.vadd(I,w.rj),w.rj.vadd(z,w.rj),w.rj.vadd(i,w.rj),w.rj.vsub(a.position,w.rj),w.ri.vadd(s,w.ri),w.ri.vsub(r.position,w.ri),d.release(z),d.release(I),this.result.push(w),this.createFrictionEquationsFromContact(w,this.frictionResult);for(let x=0,R=_.length;x!==R;x++)d.release(_[x]);return}else for(let w=0;w!==N.length;w++){const z=d.get(),I=d.get();o.vmult(y[N[(w+1)%N.length]],z),o.vmult(y[N[(w+2)%N.length]],I),i.vadd(z,z),i.vadd(I,I);const x=Di;I.vsub(z,x);const R=Xi;x.unit(R);const q=d.get(),V=d.get();s.vsub(z,V);const D=V.dot(R);R.scale(D,q),q.vadd(z,q);const G=d.get();if(q.vsub(s,G),D>0&&D*D<x.lengthSquared()&&G.lengthSquared()<m*m){if(u)return!0;const L=this.createContactEquation(r,a,t,e,l,h);q.vsub(i,L.rj),q.vsub(s,L.ni),L.ni.normalize(),L.ni.scale(m,L.ri),L.rj.vadd(i,L.rj),L.rj.vsub(a.position,L.rj),L.ri.vadd(s,L.ri),L.ri.vsub(r.position,L.ri),this.result.push(L),this.createFrictionEquationsFromContact(L,this.frictionResult);for(let ct=0,wt=_.length;ct!==wt;ct++)d.release(_[ct]);d.release(z),d.release(I),d.release(q),d.release(G),d.release(V);return}d.release(z),d.release(I),d.release(q),d.release(G),d.release(V)}for(let w=0,z=_.length;w!==z;w++)d.release(_[w])}}}planeConvex(t,e,s,i,n,o,r,a,l,h,u){const d=en,f=sn;f.set(0,0,1),n.vmult(f,f);let p=0;const y=nn;for(let m=0;m!==e.vertices.length;m++)if(d.copy(e.vertices[m]),o.vmult(d,d),i.vadd(d,d),d.vsub(s,y),f.dot(y)<=0){if(u)return!0;const v=this.createContactEquation(r,a,t,e,l,h),b=on;f.scale(f.dot(y),b),d.vsub(b,b),b.vsub(s,v.ri),v.ni.copy(f),d.vsub(i,v.rj),v.ri.vadd(s,v.ri),v.ri.vsub(r.position,v.ri),v.rj.vadd(i,v.rj),v.rj.vsub(a.position,v.rj),this.result.push(v),p++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(v,this.frictionResult)}this.enableFrictionReduction&&p&&this.createFrictionFromAverage(p)}boxConvex(t,e,s,i,n,o,r,a,l,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,s,i,n,o,r,a,t,e,u)}sphereHeightfield(t,e,s,i,n,o,r,a,l,h,u){const d=e.data,f=t.radius,p=e.elementSize,y=gn,m=wn;k.pointToLocalFrame(i,o,s,m);let g=Math.floor((m.x-f)/p)-1,v=Math.ceil((m.x+f)/p)+1,b=Math.floor((m.y-f)/p)-1,E=Math.ceil((m.y+f)/p)+1;if(v<0||E<0||g>d.length||b>d[0].length)return;g<0&&(g=0),v<0&&(v=0),b<0&&(b=0),E<0&&(E=0),g>=d.length&&(g=d.length-1),v>=d.length&&(v=d.length-1),E>=d[0].length&&(E=d[0].length-1),b>=d[0].length&&(b=d[0].length-1);const N=[];e.getRectMinMax(g,b,v,E,N);const M=N[0],T=N[1];if(m.z-f>T||m.z+f<M)return;const C=this.result;for(let S=g;S<v;S++)for(let A=b;A<E;A++){const B=C.length;let _=!1;if(e.getConvexTrianglePillar(S,A,!1),k.pointToWorldFrame(i,o,e.pillarOffset,y),s.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,s,y,n,o,r,a,t,e,u)),u&&_||(e.getConvexTrianglePillar(S,A,!0),k.pointToWorldFrame(i,o,e.pillarOffset,y),s.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(_=this.sphereConvex(t,e.pillarConvex,s,y,n,o,r,a,t,e,u)),u&&_))return!0;if(C.length-B>2)return}}boxHeightfield(t,e,s,i,n,o,r,a,l,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,s,i,n,o,r,a,t,e,u)}convexHeightfield(t,e,s,i,n,o,r,a,l,h,u){const d=e.data,f=e.elementSize,p=t.boundingSphereRadius,y=mn,m=yn,g=vn;k.pointToLocalFrame(i,o,s,g);let v=Math.floor((g.x-p)/f)-1,b=Math.ceil((g.x+p)/f)+1,E=Math.floor((g.y-p)/f)-1,N=Math.ceil((g.y+p)/f)+1;if(b<0||N<0||v>d.length||E>d[0].length)return;v<0&&(v=0),b<0&&(b=0),E<0&&(E=0),N<0&&(N=0),v>=d.length&&(v=d.length-1),b>=d.length&&(b=d.length-1),N>=d[0].length&&(N=d[0].length-1),E>=d[0].length&&(E=d[0].length-1);const M=[];e.getRectMinMax(v,E,b,N,M);const T=M[0],C=M[1];if(!(g.z-p>C||g.z+p<T))for(let S=v;S<b;S++)for(let A=E;A<N;A++){let B=!1;if(e.getConvexTrianglePillar(S,A,!1),k.pointToWorldFrame(i,o,e.pillarOffset,y),s.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(B=this.convexConvex(t,e.pillarConvex,s,y,n,o,r,a,null,null,u,m,null)),u&&B||(e.getConvexTrianglePillar(S,A,!0),k.pointToWorldFrame(i,o,e.pillarOffset,y),s.distanceTo(y)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(B=this.convexConvex(t,e.pillarConvex,s,y,n,o,r,a,null,null,u,m,null)),u&&B))return!0}}sphereParticle(t,e,s,i,n,o,r,a,l,h,u){const d=dn;if(d.set(0,0,1),i.vsub(s,d),d.lengthSquared()<=t.radius*t.radius){if(u)return!0;const p=this.createContactEquation(a,r,e,t,l,h);d.normalize(),p.rj.copy(d),p.rj.scale(t.radius,p.rj),p.ni.copy(d),p.ni.negate(p.ni),p.ri.set(0,0,0),this.result.push(p),this.createFrictionEquationsFromContact(p,this.frictionResult)}}planeParticle(t,e,s,i,n,o,r,a,l,h,u){const d=ln;d.set(0,0,1),r.quaternion.vmult(d,d);const f=cn;if(i.vsub(r.position,f),d.dot(f)<=0){if(u)return!0;const y=this.createContactEquation(a,r,e,t,l,h);y.ni.copy(d),y.ni.negate(y.ni),y.ri.set(0,0,0);const m=hn;d.scale(d.dot(i),m),i.vsub(m,m),y.rj.copy(m),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}}boxParticle(t,e,s,i,n,o,r,a,l,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,s,i,n,o,r,a,t,e,u)}convexParticle(t,e,s,i,n,o,r,a,l,h,u){let d=-1;const f=pn,p=fn;let y=null;const m=un;if(m.copy(i),m.vsub(s,m),n.conjugate(je),je.vmult(m,m),t.pointIsInside(m)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(s,n),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(n);for(let g=0,v=t.faces.length;g!==v;g++){const b=[t.worldVertices[t.faces[g][0]]],E=t.worldFaceNormals[g];i.vsub(b[0],He);const N=-E.dot(He);if(y===null||Math.abs(N)<Math.abs(y)){if(u)return!0;y=N,d=g,f.copy(E)}}if(d!==-1){const g=this.createContactEquation(a,r,e,t,l,h);f.scale(y,p),p.vadd(i,p),p.vsub(s,p),g.rj.copy(p),f.negate(g.ni),g.ri.set(0,0,0);const v=g.ri,b=g.rj;v.vadd(i,v),v.vsub(a.position,v),b.vadd(s,b),b.vsub(r.position,b),this.result.push(g),this.createFrictionEquationsFromContact(g,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,s,i,n,o,r,a,l,h,u){return this.convexHeightfield(e,t,i,s,o,n,a,r,l,h,u)}particleCylinder(t,e,s,i,n,o,r,a,l,h,u){return this.convexParticle(e,t,i,s,o,n,a,r,l,h,u)}sphereTrimesh(t,e,s,i,n,o,r,a,l,h,u){const d=Ei,f=Ci,p=Si,y=zi,m=Ii,g=Ni,v=_i,b=bi,E=gi,N=Ti;k.pointToLocalFrame(i,o,s,m);const M=t.radius;v.lowerBound.set(m.x-M,m.y-M,m.z-M),v.upperBound.set(m.x+M,m.y+M,m.z+M),e.getTrianglesInAABB(v,N);const T=xi,C=t.radius*t.radius;for(let w=0;w<N.length;w++)for(let z=0;z<3;z++)if(e.getVertex(e.indices[N[w]*3+z],T),T.vsub(m,E),E.lengthSquared()<=C){if(b.copy(T),k.pointToWorldFrame(i,o,b,T),T.vsub(s,E),u)return!0;let I=this.createContactEquation(r,a,t,e,l,h);I.ni.copy(E),I.ni.normalize(),I.ri.copy(I.ni),I.ri.scale(t.radius,I.ri),I.ri.vadd(s,I.ri),I.ri.vsub(r.position,I.ri),I.rj.copy(T),I.rj.vsub(a.position,I.rj),this.result.push(I),this.createFrictionEquationsFromContact(I,this.frictionResult)}for(let w=0;w<N.length;w++)for(let z=0;z<3;z++){e.getVertex(e.indices[N[w]*3+z],d),e.getVertex(e.indices[N[w]*3+(z+1)%3],f),f.vsub(d,p),m.vsub(f,g);const I=g.dot(p);m.vsub(d,g);let x=g.dot(p);if(x>0&&I<0&&(m.vsub(d,g),y.copy(p),y.normalize(),x=g.dot(y),y.scale(x,g),g.vadd(d,g),g.distanceTo(m)<t.radius)){if(u)return!0;const q=this.createContactEquation(r,a,t,e,l,h);g.vsub(m,q.ni),q.ni.normalize(),q.ni.scale(t.radius,q.ri),q.ri.vadd(s,q.ri),q.ri.vsub(r.position,q.ri),k.pointToWorldFrame(i,o,g,g),g.vsub(a.position,q.rj),k.vectorToWorldFrame(o,q.ni,q.ni),k.vectorToWorldFrame(o,q.ri,q.ri),this.result.push(q),this.createFrictionEquationsFromContact(q,this.frictionResult)}}const S=Mi,A=Ai,B=Pi,_=wi;for(let w=0,z=N.length;w!==z;w++){e.getTriangleVertices(N[w],S,A,B),e.getNormal(N[w],_),m.vsub(S,g);let I=g.dot(_);if(_.scale(I,g),m.vsub(g,g),I=g.distanceTo(m),H.pointInTriangle(g,S,A,B)&&I<t.radius){if(u)return!0;let x=this.createContactEquation(r,a,t,e,l,h);g.vsub(m,x.ni),x.ni.normalize(),x.ni.scale(t.radius,x.ri),x.ri.vadd(s,x.ri),x.ri.vsub(r.position,x.ri),k.pointToWorldFrame(i,o,g,g),g.vsub(a.position,x.rj),k.vectorToWorldFrame(o,x.ni,x.ni),k.vectorToWorldFrame(o,x.ri,x.ri),this.result.push(x),this.createFrictionEquationsFromContact(x,this.frictionResult)}}N.length=0}planeTrimesh(t,e,s,i,n,o,r,a,l,h,u){const d=new c,f=vi;f.set(0,0,1),n.vmult(f,f);for(let p=0;p<e.vertices.length/3;p++){e.getVertex(p,d);const y=new c;y.copy(d),k.pointToWorldFrame(i,o,y,d);const m=mi;if(d.vsub(s,m),f.dot(m)<=0){if(u)return!0;const v=this.createContactEquation(r,a,t,e,l,h);v.ni.copy(f);const b=yi;f.scale(m.dot(f),b),d.vsub(b,b),v.ri.copy(b),v.ri.vsub(r.position,v.ri),v.rj.copy(d),v.rj.vsub(a.position,v.rj),this.result.push(v),this.createFrictionEquationsFromContact(v,this.frictionResult)}}}}const lt=new c,ht=new c,dt=new c,di=new c,ui=new c,pi=new j,fi=new j,vi=new c,mi=new c,yi=new c,wi=new c,gi=new c,xi=new c,bi=new c,Ei=new c,Ci=new c,Si=new c,zi=new c,Ii=new c,Ni=new c,Mi=new c,Ai=new c,Pi=new c,_i=new U,Ti=[],St=new c,We=new c,Bi=new c,Fi=new c,Li=new c;function Ri(O,t,e){let s=null;const i=O.length;for(let n=0;n!==i;n++){const o=O[n],r=Bi;O[(n+1)%i].vsub(o,r);const a=Fi;r.cross(t,a);const l=Li;e.vsub(o,l);const h=a.dot(l);if(s===null||h>0&&s===!0||h<=0&&s===!1){s===null&&(s=h>0);continue}else return!1}return!0}const zt=new c,qi=new c,Oi=new c,Vi=new c,ki=[new c,new c,new c,new c,new c,new c],Wi=new c,ji=new c,Hi=new c,Yi=new c,Gi=new c,Di=new c,Xi=new c,Ui=new c,$i=new c,Zi=new c,Ki=new c,Qi=new c,Ji=new c,tn=new c,en=new c,sn=new c,nn=new c,on=new c,rn=new c,an=new c,ln=new c,cn=new c,hn=new c,dn=new c,je=new j,un=new c,pn=new c,He=new c,fn=new c,vn=new c,mn=new c,yn=[0],wn=new c,gn=new c;class Ye{constructor(){this.current=void 0,this.previous=void 0,this.current=[],this.previous=[]}getKey(t,e){if(e<t){const s=e;e=t,t=s}return t<<16|e}set(t,e){const s=this.getKey(t,e),i=this.current;let n=0;for(;s>i[n];)n++;if(s!==i[n]){for(let o=i.length-1;o>=n;o--)i[o+1]=i[o];i[n]=s}}tick(){const t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){const s=this.current,i=this.previous,n=s.length,o=i.length;let r=0;for(let a=0;a<n;a++){let l=!1;const h=s[a];for(;h>i[r];)r++;l=h===i[r],l||Ge(t,h)}r=0;for(let a=0;a<o;a++){let l=!1;const h=i[a];for(;h>s[r];)r++;l=s[r]===h,l||Ge(e,h)}}}function Ge(O,t){O.push((t&4294901760)>>16,t&65535)}class xn{constructor(){this.data={keys:[]}}get(t,e){if(t>e){const s=e;e=t,t=s}return this.data[t+"-"+e]}set(t,e,s){if(t>e){const n=e;e=t,t=n}const i=t+"-"+e;this.get(t,e)||this.data.keys.push(i),this.data[i]=s}reset(){const t=this.data,e=t.keys;for(;e.length>0;){const s=e.pop();delete t[s]}}}class Pn extends Ut{constructor(t={}){super();this.dt=void 0,this.allowSleep=void 0,this.contacts=void 0,this.frictionEquations=void 0,this.quatNormalizeSkip=void 0,this.quatNormalizeFast=void 0,this.time=void 0,this.stepnumber=void 0,this.default_dt=void 0,this.nextId=void 0,this.gravity=void 0,this.broadphase=void 0,this.bodies=void 0,this.hasActiveBodies=void 0,this.solver=void 0,this.constraints=void 0,this.narrowphase=void 0,this.collisionMatrix=void 0,this.collisionMatrixPrevious=void 0,this.bodyOverlapKeeper=void 0,this.shapeOverlapKeeper=void 0,this.materials=void 0,this.contactmaterials=void 0,this.contactMaterialTable=void 0,this.defaultMaterial=void 0,this.defaultContactMaterial=void 0,this.doProfiling=void 0,this.profile=void 0,this.accumulator=void 0,this.subsystems=void 0,this.addBodyEvent=void 0,this.removeBodyEvent=void 0,this.idToBodyMap=void 0,this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=t.quatNormalizeSkip!==void 0?t.quatNormalizeSkip:0,this.quatNormalizeFast=t.quatNormalizeFast!==void 0?t.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new c,t.gravity&&this.gravity.copy(t.gravity),this.broadphase=t.broadphase!==void 0?t.broadphase:new gs,this.bodies=[],this.hasActiveBodies=!1,this.solver=t.solver!==void 0?t.solver:new ni,this.constraints=[],this.narrowphase=new hi(this),this.collisionMatrix=new Xt,this.collisionMatrixPrevious=new Xt,this.bodyOverlapKeeper=new Ye,this.shapeOverlapKeeper=new Ye,this.materials=[],this.contactmaterials=[],this.contactMaterialTable=new xn,this.defaultMaterial=new Ct("default"),this.defaultContactMaterial=new Et(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}numObjects(){return this.bodies.length}collisionMatrixTick(){const t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){const e=this.constraints.indexOf(t);e!==-1&&this.constraints.splice(e,1)}rayTest(t,e,s){s instanceof Lt?this.raycastClosest(t,e,{skipBackfaces:!0},s):this.raycastAll(t,e,{skipBackfaces:!0},s)}raycastAll(t,e,s={},i){return s.mode=H.ALL,s.from=t,s.to=e,s.callback=i,Vt.intersectWorld(this,s)}raycastAny(t,e,s={},i){return s.mode=H.ANY,s.from=t,s.to=e,s.result=i,Vt.intersectWorld(this,s)}raycastClosest(t,e,s={},i){return s.mode=H.CLOSEST,s.from=t,s.to=e,s.result=i,Vt.intersectWorld(this,s)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof F&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;const e=this.bodies.length-1,s=this.bodies,i=s.indexOf(t);if(i!==-1){s.splice(i,1);for(let n=0;n!==s.length;n++)s[n].index=n;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){const e=this.bodies;for(let s=0;s<e.length;s++){const i=e[s].shapes;for(let n=0;n<i.length;n++){const o=i[n];if(o.id===t)return o}}return null}addMaterial(t){this.materials.push(t)}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}step(t,e,s=10){if(e===void 0)this.internalStep(t),this.time+=t;else{this.accumulator+=e;const i=Y.now();let n=0;for(;this.accumulator>=t&&n<s&&(this.internalStep(t),this.accumulator-=t,n++,!(Y.now()-i>t*1e3)););this.accumulator=this.accumulator%t;const o=this.accumulator/t;for(let r=0;r!==this.bodies.length;r++){const a=this.bodies[r];a.previousPosition.lerp(a.position,o,a.interpolatedPosition),a.previousQuaternion.slerp(a.quaternion,o,a.interpolatedQuaternion),a.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;const e=this.contacts,s=zn,i=In,n=this.numObjects(),o=this.bodies,r=this.solver,a=this.gravity,l=this.doProfiling,h=this.profile,u=F.DYNAMIC;let d=-1/0;const f=this.constraints,p=Sn;a.length();const y=a.x,m=a.y,g=a.z;let v=0;for(l&&(d=Y.now()),v=0;v!==n;v++){const w=o[v];if(w.type===u){const z=w.force,I=w.mass;z.x+=I*y,z.y+=I*m,z.z+=I*g}}for(let w=0,z=this.subsystems.length;w!==z;w++)this.subsystems[w].update();l&&(d=Y.now()),s.length=0,i.length=0,this.broadphase.collisionPairs(this,s,i),l&&(h.broadphase=Y.now()-d);let b=f.length;for(v=0;v!==b;v++){const w=f[v];if(!w.collideConnected)for(let z=s.length-1;z>=0;z-=1)(w.bodyA===s[z]&&w.bodyB===i[z]||w.bodyB===s[z]&&w.bodyA===i[z])&&(s.splice(z,1),i.splice(z,1))}this.collisionMatrixTick(),l&&(d=Y.now());const E=Cn,N=e.length;for(v=0;v!==N;v++)E.push(e[v]);e.length=0;const M=this.frictionEquations.length;for(v=0;v!==M;v++)p.push(this.frictionEquations[v]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(s,i,this,e,E,this.frictionEquations,p),l&&(h.narrowphase=Y.now()-d),l&&(d=Y.now()),v=0;v<this.frictionEquations.length;v++)r.addEquation(this.frictionEquations[v]);const T=e.length;for(let w=0;w!==T;w++){const z=e[w],I=z.bi,x=z.bj,R=z.si,q=z.sj;let V;if(I.material&&x.material?V=this.getContactMaterial(I.material,x.material)||this.defaultContactMaterial:V=this.defaultContactMaterial,V.friction,I.material&&x.material&&(I.material.friction>=0&&x.material.friction>=0&&I.material.friction*x.material.friction,I.material.restitution>=0&&x.material.restitution>=0&&(z.restitution=I.material.restitution*x.material.restitution)),r.addEquation(z),I.allowSleep&&I.type===F.DYNAMIC&&I.sleepState===F.SLEEPING&&x.sleepState===F.AWAKE&&x.type!==F.STATIC){const D=x.velocity.lengthSquared()+x.angularVelocity.lengthSquared(),G=x.sleepSpeedLimit**2;D>=G*2&&(I.wakeUpAfterNarrowphase=!0)}if(x.allowSleep&&x.type===F.DYNAMIC&&x.sleepState===F.SLEEPING&&I.sleepState===F.AWAKE&&I.type!==F.STATIC){const D=I.velocity.lengthSquared()+I.angularVelocity.lengthSquared(),G=I.sleepSpeedLimit**2;D>=G*2&&(x.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(I,x,!0),this.collisionMatrixPrevious.get(I,x)||(vt.body=x,vt.contact=z,I.dispatchEvent(vt),vt.body=I,x.dispatchEvent(vt)),this.bodyOverlapKeeper.set(I.id,x.id),this.shapeOverlapKeeper.set(R.id,q.id)}for(this.emitContactEvents(),l&&(h.makeContactConstraints=Y.now()-d,d=Y.now()),v=0;v!==n;v++){const w=o[v];w.wakeUpAfterNarrowphase&&(w.wakeUp(),w.wakeUpAfterNarrowphase=!1)}for(b=f.length,v=0;v!==b;v++){const w=f[v];w.update();for(let z=0,I=w.equations.length;z!==I;z++){const x=w.equations[z];r.addEquation(x)}}r.solve(t,this),l&&(h.solve=Y.now()-d),r.removeAllEquations();const C=Math.pow;for(v=0;v!==n;v++){const w=o[v];if(w.type&u){const z=C(1-w.linearDamping,t),I=w.velocity;I.scale(z,I);const x=w.angularVelocity;if(x){const R=C(1-w.angularDamping,t);x.scale(R,x)}}}for(this.dispatchEvent(En),v=0;v!==n;v++){const w=o[v];w.preStep&&w.preStep.call(w)}l&&(d=Y.now());const A=this.stepnumber%(this.quatNormalizeSkip+1)==0,B=this.quatNormalizeFast;for(v=0;v!==n;v++)o[v].integrate(t,A,B);for(this.clearForces(),this.broadphase.dirty=!0,l&&(h.integrate=Y.now()-d),this.stepnumber+=1,this.dispatchEvent(bn),v=0;v!==n;v++){const w=o[v],z=w.postStep;z&&z.call(w)}let _=!0;if(this.allowSleep)for(_=!1,v=0;v!==n;v++){const w=o[v];w.sleepTick(this.time),w.sleepState!==F.SLEEPING&&(_=!0)}this.hasActiveBodies=_}emitContactEvents(){const t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(tt,et),t){for(let n=0,o=tt.length;n<o;n+=2)mt.bodyA=this.getBodyById(tt[n]),mt.bodyB=this.getBodyById(tt[n+1]),this.dispatchEvent(mt);mt.bodyA=mt.bodyB=null}if(e){for(let n=0,o=et.length;n<o;n+=2)yt.bodyA=this.getBodyById(et[n]),yt.bodyB=this.getBodyById(et[n+1]),this.dispatchEvent(yt);yt.bodyA=yt.bodyB=null}tt.length=et.length=0;const s=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((s||i)&&this.shapeOverlapKeeper.getDiff(tt,et),s){for(let n=0,o=tt.length;n<o;n+=2){const r=this.getShapeById(tt[n]),a=this.getShapeById(tt[n+1]);st.shapeA=r,st.shapeB=a,r&&(st.bodyA=r.body),a&&(st.bodyB=a.body),this.dispatchEvent(st)}st.bodyA=st.bodyB=st.shapeA=st.shapeB=null}if(i){for(let n=0,o=et.length;n<o;n+=2){const r=this.getShapeById(et[n]),a=this.getShapeById(et[n+1]);it.shapeA=r,it.shapeB=a,r&&(it.bodyA=r.body),a&&(it.bodyB=a.body),this.dispatchEvent(it)}it.bodyA=it.bodyB=it.shapeA=it.shapeB=null}}clearForces(){const t=this.bodies,e=t.length;for(let s=0;s!==e;s++){const i=t[s];i.force,i.torque,i.force.set(0,0,0),i.torque.set(0,0,0)}}}new U;const Vt=new H,Y=globalThis.performance||{};if(!Y.now){let O=Date.now();Y.timing&&Y.timing.navigationStart&&(O=Y.timing.navigationStart),Y.now=()=>Date.now()-O}const bn={type:"postStep"},En={type:"preStep"},vt={type:F.COLLIDE_EVENT_NAME,body:null,contact:null},Cn=[],Sn=[],zn=[],In=[],tt=[],et=[],mt={type:"beginContact",bodyA:null,bodyB:null},yt={type:"endContact",bodyA:null,bodyB:null},st={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},it={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};function _n(O,t,{color:e=65280,scale:s=1,onInit:i,onUpdate:n,autoUpdate:o}={}){const r=[],a=new De({color:e!=null?e:65280,wireframe:!0}),l=new c,h=new c,u=new c,d=new j,f=new Wt(1),p=new jt(1,1,1),y=new Ht(10,10,10,10);function m(C){const S=new Mt,A=[];for(let _=0;_<C.vertices.length;_++){const w=C.vertices[_];A.push(w.x,w.y,w.z)}S.setAttribute("position",new At(A,3));const B=[];for(let _=0;_<C.faces.length;_++){const w=C.faces[_],z=w[0];for(let I=1;I<w.length-1;I++){const x=w[I],R=w[I+1];B.push(z,x,R)}}return S.setIndex(B),S.computeBoundingSphere(),S.computeVertexNormals(),S}function g(C){const S=new Mt,A=[],B=l,_=h,w=u;for(let z=0;z<C.indices.length/3;z++)C.getTriangleVertices(z,B,_,w),A.push(B.x,B.y,B.z),A.push(_.x,_.y,_.z),A.push(w.x,w.y,w.z);return S.setAttribute("position",new At(A,3)),S.computeBoundingSphere(),S.computeVertexNormals(),S}function v(C){const S=new Mt,A=C.elementSize||1,B=C.data.flatMap((w,z)=>w.flatMap((I,x)=>[z*A,x*A,I])),_=[];for(let w=0;w<C.data.length-1;w++)for(let z=0;z<C.data[w].length-1;z++){const I=C.data[w].length,x=w*I+z;_.push(x+1,x+I,x+I+1),_.push(x+I,x+1,x)}return S.setIndex(_),S.setAttribute("position",new At(B,3)),S.computeBoundingSphere(),S.computeVertexNormals(),S}function b(C){let S=new nt;const{SPHERE:A,BOX:B,PLANE:_,CYLINDER:w,CONVEXPOLYHEDRON:z,TRIMESH:I,HEIGHTFIELD:x}=P.types;switch(C.type){case A:{S=new nt(f,a);break}case B:{S=new nt(p,a);break}case _:{S=new nt(y,a);break}case w:{const R=new Xe(C.radiusTop,C.radiusBottom,C.height,C.numSegments);S=new nt(R,a),C.geometryId=R.id;break}case z:{const R=m(C);S=new nt(R,a),C.geometryId=R.id;break}case I:{const R=g(C);S=new nt(R,a),C.geometryId=R.id;break}case x:{const R=v(C);S=new nt(R,a),C.geometryId=R.id;break}}return O.add(S),S}function E(C,S){const{SPHERE:A,BOX:B,PLANE:_,CYLINDER:w,CONVEXPOLYHEDRON:z,TRIMESH:I,HEIGHTFIELD:x}=P.types;switch(S.type){case A:{const{radius:R}=S;C.scale.set(R*s,R*s,R*s);break}case B:{C.scale.copy(S.halfExtents),C.scale.multiplyScalar(2*s);break}case _:break;case w:{C.scale.set(1*s,1*s,1*s);break}case z:{C.scale.set(1*s,1*s,1*s);break}case I:{C.scale.copy(S.scale).multiplyScalar(s);break}case x:{C.scale.set(1*s,1*s,1*s);break}}}function N(C,S){if(!C)return!1;const{geometry:A}=C;return A instanceof Wt&&S.type===P.types.SPHERE||A instanceof jt&&S.type===P.types.BOX||A instanceof Ht&&S.type===P.types.PLANE||A.id===S.geometryId&&S.type===P.types.CYLINDER||A.id===S.geometryId&&S.type===P.types.CONVEXPOLYHEDRON||A.id===S.geometryId&&S.type===P.types.TRIMESH||A.id===S.geometryId&&S.type===P.types.HEIGHTFIELD}function M(C,S){let A=r[C],B=!1;return N(A,S)||(A&&O.remove(A),r[C]=A=b(S),B=!0),E(A,S),B}function T(){const C=r,S=l,A=d;let B=0;for(const _ of t)for(let w=0;w!==_.shapes.length;w++){const z=_.shapes[w],I=M(B,z),x=C[B];x&&(_.quaternion.vmult(_.shapeOffsets[w],S),_.position.vadd(S,S),_.quaternion.mult(_.shapeOrientations[w],A),x.position.copy(S),x.quaternion.copy(A),I&&i instanceof Function&&i(_,x,z),!I&&n instanceof Function&&n(_,x,z)),B++}for(let _=B;_<C.length;_++){const w=C[_];w&&O.remove(w)}C.length=B,o!==!1&&requestAnimationFrame(T)}return o!==!1&&requestAnimationFrame(T),{update:T}}export{F as B,Mn as C,An as H,j as Q,pt as S,c as V,Pn as W,Tt as a,_n as c};
